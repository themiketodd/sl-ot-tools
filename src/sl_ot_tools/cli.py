#!/usr/bin/env python3
"""
sl-ot-tools — CLI for Silver Lake Operating Technology tools.

Commands:
    init company <slug>      Create a new company repo structure
    init engagement <name>   Create a new engagement directory
    setup                    Update skills and viewer (safe to re-run)
    setup --reconfigure      Re-prompt for user config values
    settings                 Configure user-level settings (~/.config/sl-ot-tools/)
    check                    Verify installation and config
    generate-viewer          Regenerate org chart viewer from template
    migrate-registry         Build engagement_registry.json from legacy data
    validate-registry        Validate registry against org chart and configs
    index-files              Scan and index engagement documents + email attachments
    extract-text [--force]   Extract text from indexed documents into markdown summaries
"""

import json
import os
import shutil
import sys
from pathlib import Path

from . import __version__
from .config.resolver import (
    find_company_dir,
    find_engagement_dir,
    find_local_dir,
    find_repo_root,
    load_json,
    load_user_config,
)


def _get_templates_dir():
    return Path(__file__).parent / "templates"


def _get_viewer_template():
    return Path(__file__).parent / "viewer" / "org_chart_template.html"


# ── init company ──────────────────────────────────────────────

def cmd_init_company(slug):
    """Create a new company repo structure."""
    target = Path.cwd() / slug if not Path(slug).is_absolute() else Path(slug)
    if target.exists() and any(target.iterdir()):
        print(f"ERROR: Directory {target} already exists and is not empty")
        sys.exit(1)

    company_dir = target / "_company"
    local_dir = target / ".local"

    company_dir.mkdir(parents=True, exist_ok=True)
    local_dir.mkdir(parents=True, exist_ok=True)
    (target / ".claude" / "commands").mkdir(parents=True, exist_ok=True)

    # company_config.json
    company_config = {
        "company": slug.replace("-", " ").title(),
        "domains": [],
        "domain_labels": {},
        "skip_senders": [],
        "contractor_patterns": ["^[a-z]+x\\."],
        "location_hints": [],
    }
    _write_json(company_dir / "company_config.json", company_config)

    # people_config.json
    people_config = {
        "org_chart": "org_chart.json",
        "checkpoint": "people_checkpoint.json",
        "ignore_list": "people_ignore.json",
    }
    _write_json(company_dir / "people_config.json", people_config)

    # Empty org_chart.json (no key_programs — use engagement_registry.json instead)
    org_chart = {
        "company": company_config["company"],
        "generated": "",
        "leadership": [],
        "people": [],
        "external_ecosystem": {},
    }
    _write_json(company_dir / "org_chart.json", org_chart)

    # Empty engagement_registry.json
    from .registry import GOVERNANCE_TYPES, save_registry
    registry = {
        "governance_types": dict(GOVERNANCE_TYPES),
        "engagements": {},
    }
    save_registry(company_dir, registry)

    # Empty checkpoints
    _write_json(company_dir / "people_checkpoint.json", {
        "last_updated": None,
        "processed_ids": [],
        "total_processed": 0,
    })
    _write_json(company_dir / "people_ignore.json", {"ignored": []})

    # .gitignore
    gitignore = """# OS files
.DS_Store
Thumbs.db
Desktop.ini

# Binary/Office files — these live in SharePoint, not git
# Use sync scripts to pull them locally
*.docx
*.xlsx
*.pptx
*.pdf
*.zip

# Office temp/lock files
~$*
*.tmp

# Zone.Identifier files (Windows/WSL artifacts)
*.Zone.Identifier
*:Zone.Identifier

# Per-user local state (gitignored)
.local/

# Claude Code (keep commands/ for shared skills)
.claude/*
!.claude/commands/

# OneDrive conflict files
*-conflict-*
*(1).*

# Python
__pycache__/
*.pyc
"""
    (target / ".gitignore").write_text(gitignore)

    # CLAUDE.md
    claude_md = f"""# {company_config['company']}

This is a Silver Lake portfolio company repo managed with sl-ot-tools.

## Structure

- `_company/` — Company-level shared data (org chart, configs, people data)
- `.local/` — Per-user config and ephemeral data (gitignored)
- `.claude/commands/` — Claude Code skills (generated by `sl-ot-tools setup`)
- Each top-level directory (other than the above) is an engagement

## Tools

All tools are installed via `pip install sl-ot-tools` and available on PATH:
- `sl-ot-sync` — Bidirectional sync with SharePoint
- `sl-ot-read-emails` — Read emails from Outlook
- `sl-ot-process-people` — Scan emails for people signals
- `sl-ot-md2docx` — Convert markdown to Word documents

## Setup

Run `sl-ot-tools setup` after cloning to configure local paths and install skills.
"""
    (target / "CLAUDE.md").write_text(claude_md)

    print(f"Created company repo: {target}")
    print(f"  _company/company_config.json  — edit domains, labels, patterns")
    print(f"  _company/org_chart.json       — seed with known leadership")
    print(f"  .gitignore                    — configured")
    print()
    print("Next steps:")
    print(f"  cd {slug}")
    print(f"  # Edit _company/company_config.json")
    print(f"  sl-ot-tools init engagement <name>")
    print(f"  sl-ot-tools setup")


def cmd_init_engagement(name):
    """Create a new engagement directory."""
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        print("Run 'sl-ot-tools init company <slug>' first")
        sys.exit(1)

    eng_dir = repo_root / name
    if eng_dir.exists() and any(eng_dir.iterdir()):
        print(f"ERROR: Directory {eng_dir} already exists and is not empty")
        sys.exit(1)

    eng_dir.mkdir(parents=True, exist_ok=True)

    # engagement_config.json
    eng_config = {
        "engagement": name,
        "engagement_label": name.replace("-", " ").title(),
        "knowledge_types": [
            "decision", "technical", "status", "action",
            "blocker", "timeline", "budget", "risk",
        ],
        "skip_senders": [],
        "workstreams": {
            "general": {
                "label": "01-General",
                "output_dir": "01-General",
                "keywords_subject": [],
                "keywords_body": [],
                "people_associations": [],
            }
        },
    }
    _write_json(eng_dir / "engagement_config.json", eng_config)

    # sync-map.conf
    sync_conf = f"""# sync-map.conf — Folder mappings for {name}
#
# LOCAL_ROOT: auto-resolved from this file's parent directory
# REMOTE_ROOT: resolved from .local/user-config.json
#
# Format: LOCAL_PATH | REMOTE_PATH | LABEL
# See sl-ot-tools docs for prefix options (push:, pull:, file:)

# Company-level data (pushed to SharePoint)
push:file:../_company/org_chart.json | People | Org Chart JSON (push-only)
push:file:../_company/org_chart_viewer.html | People | Org Chart Viewer (push-only)

# Engagement workstreams — add mappings below
# 01-General | General | General workstream
"""
    (eng_dir / "sync-map.conf").write_text(sync_conf)

    # Wrapper scripts
    sync_push = f"""#!/bin/bash
# Push locally-created files to SharePoint for the {name} engagement.
exec sl-ot-sync push -c "$(dirname "$0")/sync-map.conf" "$@"
"""
    sync_pull = f"""#!/bin/bash
# Pull latest from SharePoint for the {name} engagement.
exec sl-ot-sync pull -c "$(dirname "$0")/sync-map.conf" "$@"
"""
    (eng_dir / "sync_to_sharepoint.sh").write_text(sync_push)
    (eng_dir / "sync_from_sharepoint.sh").write_text(sync_pull)
    os.chmod(eng_dir / "sync_to_sharepoint.sh", 0o755)
    os.chmod(eng_dir / "sync_from_sharepoint.sh", 0o755)

    # Default workstream directory
    (eng_dir / "01-General").mkdir(exist_ok=True)

    print(f"Created engagement: {eng_dir}")
    print(f"  engagement_config.json  — edit workstreams, keywords, people")
    print(f"  sync-map.conf           — add SharePoint folder mappings")
    print()
    print("Next steps:")
    print(f"  # Edit {name}/engagement_config.json")
    print(f"  # Edit {name}/sync-map.conf")
    print(f"  sl-ot-tools setup")


# ── setup ─────────────────────────────────────────────────────

def cmd_setup(reconfigure=False, force_skills=False):
    """Interactive setup: user config, skills, viewer.

    If user config already exists, skips interactive prompts and just
    updates skills + viewer. Use --reconfigure to re-prompt for config.
    """
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    company_dir = repo_root / "_company"
    local_dir = repo_root / ".local"
    local_dir.mkdir(exist_ok=True)

    # Load existing user config or create new
    user_config_path = local_dir / "user-config.json"
    has_existing_config = user_config_path.exists()

    if has_existing_config:
        user_config = load_json(user_config_path)
    else:
        user_config = {}

    # Find all engagements
    engagements = []
    for p in repo_root.iterdir():
        if p.is_dir() and (p / "engagement_config.json").exists():
            engagements.append(p.name)

    if not has_existing_config or reconfigure:
        # Interactive config prompts
        if has_existing_config:
            print(f"Reconfiguring: {user_config_path}")
        print()

        # Prompt for user name
        current_user = user_config.get("user", os.environ.get("USER", ""))
        user = input(f"User name [{current_user}]: ").strip() or current_user
        user_config["user"] = user

        # Prompt for OneDrive root
        current_root = user_config.get("onedrive_root", "")
        print()
        print("OneDrive root path (the folder where SharePoint shortcuts are mounted).")
        print("Example: /mnt/c/Users/jane.doe/OneDrive - Silver Lake/OT Sharepoint Shortcuts")
        onedrive_root = input(f"OneDrive root [{current_root}]: ").strip() or current_root
        user_config["onedrive_root"] = onedrive_root

        # Prompt for per-engagement SharePoint mappings
        mappings = user_config.get("onedrive_mappings", {})
        if engagements:
            print()
            print("SharePoint mappings (relative path under OneDrive root for each engagement).")
            print("Example: Companies/Altera/Enclave")
            for eng in sorted(engagements):
                current_mapping = mappings.get(eng, "")
                mapping = input(f"  {eng} [{current_mapping}]: ").strip() or current_mapping
                if mapping:
                    mappings[eng] = mapping
        user_config["onedrive_mappings"] = mappings

        # Write user config
        _write_json(user_config_path, user_config)
        print(f"\nSaved: {user_config_path}")
    else:
        print(f"Using existing config: {user_config_path}")
        print(f"  (run 'sl-ot-tools setup --reconfigure' to change)")

    # Mention settings if not configured
    from .config.settings import SETTINGS_FILE
    if not SETTINGS_FILE.exists():
        print()
        print("Tip: Run 'sl-ot-tools settings' to configure user-level preferences")
        print("     (timezone, PowerShell path, Word template, email defaults)")

    # Install skills
    _install_skills(repo_root, engagements, force=force_skills)

    # Generate viewer
    _generate_viewer(company_dir)

    # Verify
    print()
    cmd_check(quiet=False)


# ── check ─────────────────────────────────────────────────────

def cmd_check(quiet=False):
    """Verify installation and config."""
    issues = []
    ok_items = []

    # Check package version
    ok_items.append(f"sl-ot-tools v{__version__}")

    # Check repo structure
    repo_root = find_repo_root()
    if not repo_root:
        issues.append("Not inside a company repo (_company/ not found)")
        if not quiet:
            _print_check_results(ok_items, issues)
        return len(issues) == 0

    ok_items.append(f"Repo root: {repo_root}")

    company_dir = repo_root / "_company"

    # Check configs exist
    for cfg in ["company_config.json", "people_config.json", "org_chart.json"]:
        path = company_dir / cfg
        if path.exists():
            try:
                load_json(path)
                ok_items.append(f"Valid JSON: _company/{cfg}")
            except Exception as e:
                issues.append(f"Invalid JSON: _company/{cfg} — {e}")
        else:
            issues.append(f"Missing: _company/{cfg}")

    # Check user config
    local_dir = repo_root / ".local"
    user_config_path = local_dir / "user-config.json"
    if user_config_path.exists():
        try:
            uc = load_json(user_config_path)
            ok_items.append(f"User config: {uc.get('user', '?')}")

            # Check OneDrive root exists
            odr = uc.get("onedrive_root", "")
            if odr and os.path.isdir(odr):
                ok_items.append(f"OneDrive root exists: {odr}")
            elif odr:
                issues.append(f"OneDrive root not found: {odr}")

            # Check engagement mappings resolve
            for eng, rel_path in uc.get("onedrive_mappings", {}).items():
                full_path = os.path.join(odr, rel_path)
                if os.path.isdir(full_path):
                    ok_items.append(f"SharePoint path exists: {eng} → {rel_path}")
                else:
                    issues.append(f"SharePoint path not found: {eng} → {full_path}")
        except Exception as e:
            issues.append(f"Invalid user config: {e}")
    else:
        issues.append("Missing: .local/user-config.json — run 'sl-ot-tools setup'")

    # Check engagements
    for p in sorted(repo_root.iterdir()):
        if p.is_dir() and (p / "engagement_config.json").exists():
            try:
                load_json(p / "engagement_config.json")
                ok_items.append(f"Engagement: {p.name}")
            except Exception as e:
                issues.append(f"Invalid engagement config: {p.name} — {e}")

    # Check viewer
    viewer_path = company_dir / "org_chart_viewer.html"
    if viewer_path.exists():
        ok_items.append("Viewer: org_chart_viewer.html")
    else:
        issues.append("Missing: _company/org_chart_viewer.html — run 'sl-ot-tools generate-viewer'")

    # Check skills
    skills_dir = repo_root / ".claude" / "commands"
    if skills_dir.exists() and any(skills_dir.iterdir()):
        skill_count = len(list(skills_dir.glob("*.md")))
        ok_items.append(f"Skills installed: {skill_count}")
    else:
        issues.append("No skills installed — run 'sl-ot-tools setup'")

    if not quiet:
        _print_check_results(ok_items, issues)

    return len(issues) == 0


def _print_check_results(ok_items, issues):
    print("\n=== sl-ot-tools check ===")
    for item in ok_items:
        print(f"  OK  {item}")
    for issue in issues:
        print(f"  !!  {issue}")
    print()
    if issues:
        print(f"{len(issues)} issue(s) found.")
    else:
        print("All checks passed.")


# ── generate-viewer ───────────────────────────────────────────

def cmd_generate_viewer():
    """Regenerate org chart viewer from template."""
    company_dir = find_company_dir()
    if not company_dir:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    _generate_viewer(company_dir)


def _generate_viewer(company_dir):
    """Generate viewer HTML from template + company config.

    Embeds org_chart.json and engagement_map.json directly into the HTML
    so the viewer works from file:// without a web server.
    """
    template_path = _get_viewer_template()
    if not template_path.exists():
        print(f"WARNING: Viewer template not found at {template_path}")
        return

    # Get company name from config
    company_config_path = company_dir / "company_config.json"
    company_name = "Company"
    if company_config_path.exists():
        try:
            cc = load_json(company_config_path)
            company_name = cc.get("company", "Company")
        except Exception:
            pass

    # Build engagement map data (also writes the standalone JSON file)
    engagement_map = _generate_engagement_map(company_dir)

    # Read org chart data for embedding
    org_chart_path = company_dir / "org_chart.json"
    org_chart_json = "null"
    if org_chart_path.exists():
        try:
            org_data = load_json(org_chart_path)
            org_chart_json = json.dumps(org_data, ensure_ascii=False)
        except Exception as e:
            print(f"  WARNING: Could not read org_chart.json for embedding: {e}")

    engagement_map_json = json.dumps(engagement_map, ensure_ascii=False) if engagement_map else "null"

    # Parse knowledge logs for embedding
    knowledge_entries = _parse_knowledge_logs(company_dir)
    knowledge_json = json.dumps(knowledge_entries, ensure_ascii=False) if knowledge_entries else "null"

    # Read file index data for embedding
    file_index_path = company_dir / "file_index.json"
    file_index_json = "null"
    if file_index_path.exists():
        try:
            fi_data = load_json(file_index_path)
            file_index_json = json.dumps(fi_data, ensure_ascii=False)
        except Exception as e:
            print(f"  WARNING: Could not read file_index.json for embedding: {e}")

    # Load engagement registry for embedding
    from .registry import load_registry
    registry_data = load_registry(company_dir)
    registry_json = json.dumps(registry_data, ensure_ascii=False) if registry_data else "null"

    # Build embedded data script block
    embed_script = (
        '<script>\n'
        f'window.__EMBEDDED_VERSION__ = "{__version__}";\n'
        f'window.__EMBEDDED_ORG_DATA__ = {org_chart_json};\n'
        f'window.__EMBEDDED_ENGAGEMENT_MAP__ = {engagement_map_json};\n'
        f'window.__EMBEDDED_REGISTRY__ = {registry_json};\n'
        f'window.__EMBEDDED_FILE_INDEX__ = {file_index_json};\n'
        f'window.__EMBEDDED_KNOWLEDGE__ = {knowledge_json};\n'
        '</script>\n'
    )

    template = template_path.read_text(encoding="utf-8")
    html = template.replace("{{COMPANY_NAME}}", company_name)
    html = html.replace("{{EMBEDDED_DATA}}", embed_script)

    output_path = company_dir / "org_chart_viewer.html"
    output_path.write_text(html, encoding="utf-8")
    print(f"Generated viewer: {output_path}")


def _parse_knowledge_logs(company_dir):
    """Parse all KNOWLEDGE_LOG.md files into structured entries for the viewer.

    Walks engagement workstream dirs looking for KNOWLEDGE_LOG.md files,
    parses each nugget into a dict with type, summary, programs, detail,
    source, date, engagement, and workstream.

    Returns:
        List of knowledge entry dicts, or empty list if none found.
    """
    import re

    repo_root = company_dir.parent
    entries = []

    for eng_dir in sorted(repo_root.iterdir()):
        if not eng_dir.is_dir():
            continue
        cfg_path = eng_dir / "engagement_config.json"
        if not cfg_path.exists():
            continue

        try:
            cfg = load_json(cfg_path)
        except Exception:
            continue

        eng_key = cfg.get("engagement", eng_dir.name)

        # Walk all subdirs for KNOWLEDGE_LOG.md
        for log_path in eng_dir.rglob("KNOWLEDGE_LOG.md"):
            # Determine workstream from path
            rel = log_path.parent.relative_to(eng_dir)
            ws_dir = str(rel.parts[0]) if rel.parts else ""

            # Reverse-lookup workstream key from output_dir
            ws_key = None
            for wk, wd in cfg.get("workstreams", {}).items():
                if isinstance(wd, dict) and wd.get("output_dir") == ws_dir:
                    ws_key = wk
                    break
            if not ws_key:
                ws_key = ws_dir

            try:
                text = log_path.read_text(encoding="utf-8")
            except Exception:
                continue

            current_date = ""
            current_entry = None

            for line in text.split("\n"):
                # Date header: ## 2026-02-15
                date_match = re.match(r"^##\s+(\d{4}-\d{2}-\d{2})\s*$", line)
                if date_match:
                    if current_entry:
                        entries.append(current_entry)
                        current_entry = None
                    current_date = date_match.group(1)
                    continue

                # Nugget header: ### [TYPE] Summary
                nugget_match = re.match(r"^###\s+\[(\w+)\]\s+(.+)$", line)
                if nugget_match:
                    if current_entry:
                        entries.append(current_entry)
                    current_entry = {
                        "type": nugget_match.group(1),
                        "summary": nugget_match.group(2).strip(),
                        "workstreams": [],
                        "detail": "",
                        "source": "",
                        "date": current_date,
                        "engagement": eng_key,
                        "workstream": ws_key,
                    }
                    continue

                if not current_entry:
                    continue

                # Parse metadata lines — accept both **Workstreams**: and **Programs**: (backward compat)
                ws_match = re.match(r"^-\s+\*\*(?:Workstreams?|Programs?)\*\*:\s*(.+)$", line)
                if ws_match:
                    items = [p.strip() for p in ws_match.group(1).split(",") if p.strip()]
                    current_entry["workstreams"] = items
                    continue

                detail_match = re.match(r"^-\s+\*\*Detail\*\*:\s*(.+)$", line)
                if detail_match:
                    current_entry["detail"] = detail_match.group(1).strip()
                    continue

                source_match = re.match(r"^-\s+\*\*Source\*\*:\s*(.+)$", line)
                if source_match:
                    current_entry["source"] = source_match.group(1).strip()
                    continue

            # Don't forget the last entry
            if current_entry:
                entries.append(current_entry)

    if entries:
        print(f"Parsed knowledge logs: {len(entries)} entries from {len(set(e['engagement'] + '/' + e['workstream'] for e in entries))} workstream(s)")

    return entries


def _generate_engagement_map(company_dir):
    """Scan all engagement_config.json files and build engagement_map.json.

    Returns the engagement map dict, or None if no engagements found.
    Also writes the standalone JSON file for web-server-based serving.
    """
    repo_root = company_dir.parent
    engagements = []

    for p in sorted(repo_root.iterdir()):
        if not p.is_dir():
            continue
        cfg_path = p / "engagement_config.json"
        if not cfg_path.exists():
            continue

        try:
            cfg = load_json(cfg_path)
        except Exception as e:
            print(f"  WARNING: Skipping {p.name}/engagement_config.json: {e}")
            continue

        eng_key = cfg.get("engagement", p.name)
        eng_label = cfg.get("engagement_label", eng_key.replace("-", " ").title())
        eng_sp_url = cfg.get("sharepoint_url", "")

        workstreams = []
        for ws_key, ws_data in cfg.get("workstreams", {}).items():
            if not isinstance(ws_data, dict):
                continue
            ws_entry = {
                "key": ws_key,
                "label": ws_data.get("label", ws_key),
                "people_associations": ws_data.get("people_associations", []),
            }
            ws_sp_url = ws_data.get("sharepoint_url", "")
            if ws_sp_url:
                ws_entry["sharepoint_url"] = ws_sp_url
            workstreams.append(ws_entry)

        eng_entry = {
            "key": eng_key,
            "label": eng_label,
            "workstreams": workstreams,
        }
        if eng_sp_url:
            eng_entry["sharepoint_url"] = eng_sp_url
        engagements.append(eng_entry)

    if engagements:
        engagement_map = {"engagements": engagements}
        output_path = company_dir / "engagement_map.json"
        _write_json(output_path, engagement_map)
        print(f"Generated engagement map: {output_path} ({len(engagements)} engagement(s))")
        return engagement_map
    else:
        print("  No engagement configs found — skipping engagement_map.json")
        return None


# ── skill installation ────────────────────────────────────────

def _install_skills(repo_root, engagements, force=False):
    """Install Claude Code skills from templates.

    Detects user-modified skill files and preserves them (with a warning)
    unless force=True. Custom skills (files not matching any template)
    are always preserved.
    """
    templates_dir = _get_templates_dir() / "commands"
    target_dir = repo_root / ".claude" / "commands"
    target_dir.mkdir(parents=True, exist_ok=True)

    company_dir = repo_root / "_company"
    company_name = "Company"
    cc_path = company_dir / "company_config.json"
    if cc_path.exists():
        try:
            cc = load_json(cc_path)
            company_name = cc.get("company", "Company")
        except Exception:
            pass

    if not templates_dir.exists():
        print("WARNING: Skill templates not found")
        return

    from .config.settings import PROMPTS_DIR

    # Build engagement resolution block for skills that operate per-engagement
    if engagements:
        eng_list = ", ".join(f"`{e}`" for e in sorted(engagements))
        engagement_resolution = (
            f"## Engagement resolution\n\n"
            f"This skill operates within an engagement directory. "
            f"Available engagements: {eng_list}.\n\n"
            f"To determine which engagement to use (`<engagement>` in paths below):\n"
            f"1. If the current working directory is inside an engagement directory, use that engagement\n"
            f"2. If there's only one engagement, use it automatically\n"
            f"3. Otherwise, ask the user which engagement to target"
        )
    else:
        engagement_resolution = (
            "## Engagement resolution\n\n"
            "No engagements found. Run `sl-ot-tools init engagement <name>` first, "
            "then `sl-ot-tools setup` to reinstall skills."
        )

    installed = 0
    skipped = 0
    for template_file in templates_dir.glob("*.md"):
        content = template_file.read_text(encoding="utf-8")
        content = content.replace("{{COMPANY_DIR}}", "_company")
        content = content.replace("{{PROMPTS_DIR}}", str(PROMPTS_DIR))
        content = content.replace("{{ENGAGEMENT_RESOLUTION}}", engagement_resolution)
        content = content.replace("{{COMPANY_NAME}}", company_name)

        target_file = target_dir / template_file.name

        # Check for user modifications before overwriting
        if target_file.exists() and not force:
            existing = target_file.read_text(encoding="utf-8")
            if existing == content:
                installed += 1  # already up to date
                continue
            # File differs — could be user edits or stale template output.
            # Back up and warn rather than silently overwriting.
            backup_file = target_file.with_suffix(".md.bak")
            backup_file.write_text(existing, encoding="utf-8")
            print(f"  Updated: {template_file.name} (backup: {backup_file.name})")

        target_file.write_text(content, encoding="utf-8")
        installed += 1

    if skipped:
        print(f"Installed {installed} skills, skipped {skipped} with local edits")
        print(f"  Use 'sl-ot-tools setup --force' to overwrite all skills")
    else:
        print(f"Installed {installed} skills to .claude/commands/")


# ── migrate-registry ─────────────────────────────────────────

def cmd_migrate_registry():
    """Build engagement_registry.json from legacy key_programs + engagement configs."""
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    company_dir = repo_root / "_company"

    from .registry import build_registry_from_legacy, save_registry

    print("Building engagement registry from legacy data...")
    registry = build_registry_from_legacy(repo_root)

    eng_count = len(registry.get("engagements", {}))
    ws_count = sum(
        len(e.get("workstreams", {}))
        for e in registry.get("engagements", {}).values()
    )
    print(f"  Found {eng_count} engagement(s) with {ws_count} workstream(s)")

    path = save_registry(company_dir, registry)
    print(f"  Written: {path}")

    # Offer to strip legacy fields
    print()
    print("The registry is now the source of truth. Legacy fields can be removed:")
    print("  - key_programs from _company/org_chart.json")
    print("  - programs arrays from engagement_config.json workstreams")
    print()
    answer = input("Strip legacy fields? [y/N] ").strip().lower()
    if answer in ("y", "yes"):
        _strip_legacy_fields(repo_root)
    else:
        print("  Skipped — legacy fields preserved (you can remove them manually later)")

    # Run validation
    print()
    cmd_validate_registry()


def _strip_legacy_fields(repo_root):
    """Remove key_programs from org_chart and programs from engagement configs."""
    company_dir = repo_root / "_company"
    org_chart_path = company_dir / "org_chart.json"

    if org_chart_path.exists():
        org_data = load_json(org_chart_path)
        if "key_programs" in org_data:
            del org_data["key_programs"]
            _write_json(org_chart_path, org_data)
            print(f"  Stripped key_programs from {org_chart_path.name}")

    for eng_dir in sorted(repo_root.iterdir()):
        if not eng_dir.is_dir():
            continue
        cfg_path = eng_dir / "engagement_config.json"
        if not cfg_path.exists():
            continue
        try:
            cfg = load_json(cfg_path)
        except Exception:
            continue
        changed = False
        for ws_key, ws_data in cfg.get("workstreams", {}).items():
            if isinstance(ws_data, dict) and "programs" in ws_data:
                del ws_data["programs"]
                changed = True
        if changed:
            _write_json(cfg_path, cfg)
            print(f"  Stripped programs from {eng_dir.name}/engagement_config.json")


def cmd_validate_registry():
    """Validate engagement registry against org chart and configs."""
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    from .registry import validate_registry

    result = validate_registry(repo_root)

    if "error" in result:
        print(f"ERROR: {result['error']}")
        sys.exit(1)

    print("=== Registry Validation ===")

    if result["raci_mismatches"]:
        print(f"\n  RACI mismatches ({len(result['raci_mismatches'])}):")
        for m in result["raci_mismatches"]:
            ws = f"/{m['workstream']}" if m["workstream"] else ""
            print(f"    {m['engagement']}{ws} [{m['role']}]: {m['reason']}")

    if result["orphan_engagements"]:
        print(f"\n  Orphan engagements (in registry, no engagement dir):")
        for e in result["orphan_engagements"]:
            print(f"    {e}")

    if result["orphan_workstreams"]:
        print(f"\n  Orphan workstreams (in config, not in registry):")
        for eng, ws in result["orphan_workstreams"]:
            print(f"    {eng}/{ws}")

    if result["valid"]:
        print("\n  All checks passed.")
    else:
        issues = (
            len(result["raci_mismatches"])
            + len(result["orphan_engagements"])
            + len(result["orphan_workstreams"])
        )
        print(f"\n  {issues} issue(s) found.")


# ── index-files ──────────────────────────────────────────────

def cmd_index_files():
    """Scan and index engagement documents and email attachments."""
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    company_dir = repo_root / "_company"

    from .documents.indexer import build_file_index, save_file_index

    print("Scanning engagement directories and email attachments...")
    index = build_file_index(repo_root)

    path = save_file_index(company_dir, index)
    print(f"File index: {path}")
    print(f"  Total files: {index['total_files']}")
    print(f"  Primary: {index['primary_files']}")
    print(f"  Duplicates: {index['duplicates']}")

    # Breakdown by engagement
    by_eng = {}
    for entry in index["files"]:
        eng = entry.get("engagement") or "(unclassified)"
        by_eng.setdefault(eng, 0)
        if entry.get("is_primary", True):
            by_eng[eng] += 1
    for eng, count in sorted(by_eng.items()):
        print(f"    {eng}: {count} primary files")


# ── extract-text ─────────────────────────────────────────────

def cmd_extract_text(force=False):
    """Extract text from indexed documents into markdown summaries."""
    repo_root = find_repo_root()
    if not repo_root:
        print("ERROR: Not inside a company repo (_company/ not found)")
        sys.exit(1)

    from .documents.summarizer import summarize_files

    print("Extracting text from indexed documents...")
    result = summarize_files(repo_root, force=force)

    if "error" in result:
        print(f"ERROR: {result['error']}")
        sys.exit(1)

    print(f"  Extracted: {result['extracted']}")
    print(f"  Skipped (unchanged/unapproved): {result['skipped']}")
    if result["errors"]:
        print(f"  Errors: {len(result['errors'])}")
        for err in result["errors"]:
            print(f"    {err}")


# ── helpers ───────────────────────────────────────────────────

def _write_json(path, data):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
        f.write("\n")


# ── main ──────────────────────────────────────────────────────

def main():
    args = sys.argv[1:]

    if not args or args[0] in ("-h", "--help"):
        print(f"sl-ot-tools v{__version__}")
        print()
        print("Commands:")
        print("  init company <slug>      Create a new company repo")
        print("  init engagement <name>   Create a new engagement directory")
        print("  setup                    Update skills and viewer (re-run safely)")
        print("    --reconfigure          Re-prompt for user config values")
        print("    --force                Overwrite modified skill files")
        print("  settings                 Configure user-level settings")
        print("  check                    Verify installation and config")
        print("  generate-viewer          Regenerate org chart viewer")
        print("  migrate-registry         Build registry from legacy data")
        print("  validate-registry        Validate registry RACI + orphans")
        print("  index-files              Scan and index documents")
        print("  extract-text [--force]   Extract text from indexed documents")
        print()
        print("  --version                Show version")
        sys.exit(0)

    if args[0] == "--version":
        print(f"sl-ot-tools v{__version__}")
        sys.exit(0)

    if args[0] == "init":
        if len(args) < 3:
            print("Usage: sl-ot-tools init <company|engagement> <name>")
            sys.exit(1)
        if args[1] == "company":
            cmd_init_company(args[2])
        elif args[1] == "engagement":
            cmd_init_engagement(args[2])
        else:
            print(f"Unknown init type: {args[1]}")
            print("Usage: sl-ot-tools init <company|engagement> <name>")
            sys.exit(1)

    elif args[0] == "settings":
        from .config.settings import init_settings
        init_settings()

    elif args[0] == "setup":
        reconfigure = "--reconfigure" in args
        force_skills = "--force" in args
        cmd_setup(reconfigure=reconfigure, force_skills=force_skills)

    elif args[0] == "check":
        success = cmd_check()
        sys.exit(0 if success else 1)

    elif args[0] == "generate-viewer":
        cmd_generate_viewer()

    elif args[0] == "migrate-registry":
        cmd_migrate_registry()

    elif args[0] == "validate-registry":
        cmd_validate_registry()

    elif args[0] == "index-files":
        cmd_index_files()

    elif args[0] == "extract-text":
        force = "--force" in args
        cmd_extract_text(force=force)

    else:
        print(f"Unknown command: {args[0]}")
        print("Run 'sl-ot-tools --help' for usage")
        sys.exit(1)


if __name__ == "__main__":
    main()
