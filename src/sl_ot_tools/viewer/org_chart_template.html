<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>{{COMPANY_NAME}} — Org Chart</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-deep: #0c0e1a;
    --bg-panel: #111425;
    --bg-surface: #161935;
    --border: rgba(255,255,255,0.06);
    --border-hover: rgba(255,255,255,0.12);
    --text-primary: #e8eaf0;
    --text-secondary: #7a7f96;
    --text-muted: #4a4f66;
    --accent: #4c8dff;
    --accent-glow: rgba(76,141,255,0.15);
    --accent-hover: #6ba1ff;
    --green: #5ce0a0;
    --green-dim: rgba(92,224,160,0.12);
    --red: #ff6b7a;
    --orange: #f5a623;
    --sidebar-w: 232px;
    --toolbar-h: 44px;
    --header-h: 54px;
    --radius: 6px;
    --font: 'DM Sans', system-ui, -apple-system, sans-serif;
    --mono: 'JetBrains Mono', monospace;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg-deep);
    color: var(--text-primary);
    font-family: var(--font);
    height: 100vh;
    overflow: hidden;
    display: flex;
  }

  /* ── Sidebar ── */
  #sidebar {
    width: var(--sidebar-w); min-width: var(--sidebar-w);
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex; flex-direction: column;
    overflow-y: auto; flex-shrink: 0;
    transition: width .2s ease, min-width .2s ease, opacity .2s ease;
  }
  #sidebar::-webkit-scrollbar { width: 4px; }
  #sidebar::-webkit-scrollbar-track { background: transparent; }
  #sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 4px; }
  #sidebar.collapsed { width: 0; min-width: 0; overflow: hidden; border: none; opacity: 0; }
  .sidebar-header {
    padding: 14px 16px; font-size: 11px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.2px;
    color: var(--text-secondary);
    border-bottom: 1px solid var(--border);
    display: flex; justify-content: space-between; align-items: center;
  }
  .sidebar-header button {
    background: none; border: none; color: var(--text-muted);
    cursor: pointer; font-size: 15px; line-height: 1;
    transition: color .15s;
  }
  .sidebar-header button:hover { color: var(--text-primary); }
  .filter-section { padding: 14px 16px; border-bottom: 1px solid var(--border); }
  .filter-section h3 {
    font-size: 9px; text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-muted); margin-bottom: 10px; font-weight: 500;
  }
  .filter-item {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; font-size: 12.5px; cursor: pointer;
    color: var(--text-primary); transition: color .15s;
    font-weight: 400;
  }
  .filter-item:hover { color: #fff; }
  .filter-item.child { padding-left: 20px; font-size: 12px; color: var(--text-secondary); }
  .filter-item.child:hover { color: var(--text-primary); }
  .filter-item input[type="checkbox"] {
    accent-color: var(--accent); cursor: pointer;
    width: 13px; height: 13px;
  }
  .filter-item.disabled { color: var(--text-muted); }
  .filter-item .sw {
    width: 8px; height: 8px; border-radius: 2px;
    display: inline-block; flex-shrink: 0;
  }
  #sidebar .reset-btn {
    margin: 14px 16px; padding: 7px 14px;
    background: transparent; color: var(--text-secondary);
    border: 1px solid var(--border-hover); border-radius: var(--radius);
    cursor: pointer; font-size: 11px; font-family: var(--font);
    font-weight: 500; letter-spacing: 0.3px;
    transition: all .15s;
  }
  #sidebar .reset-btn:hover {
    background: var(--accent-glow); color: var(--accent);
    border-color: rgba(76,141,255,0.3);
  }

  /* ── Main ── */
  #main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

  /* ── Header ── */
  header {
    padding: 12px 24px; background: var(--bg-panel);
    border-bottom: 1px solid var(--border); flex-shrink: 0;
    display: flex; align-items: baseline; gap: 16px;
  }
  h1 {
    font-size: 15px; color: #fff; font-weight: 600;
    letter-spacing: -0.2px;
  }
  .subtitle {
    color: var(--text-muted); font-size: 11px;
    font-family: var(--mono); font-weight: 400;
  }

  /* ── Toolbar ── */
  .toolbar {
    display: flex; align-items: center; gap: 6px; padding: 7px 24px;
    background: var(--bg-panel); border-bottom: 1px solid var(--border);
    flex-shrink: 0; flex-wrap: wrap;
  }
  .toolbar .btn-group {
    display: flex; gap: 1px; background: var(--border);
    border-radius: var(--radius); overflow: hidden;
  }
  .toolbar button {
    background: var(--bg-surface); color: var(--text-secondary);
    border: none; padding: 5px 12px; cursor: pointer;
    font-size: 11.5px; font-family: var(--font); font-weight: 500;
    transition: all .12s; letter-spacing: 0.2px;
  }
  .toolbar button:hover { background: #1e2345; color: var(--text-primary); }
  .toolbar button:active { background: #252a50; }
  .toolbar .btn-group button:first-child { border-radius: var(--radius) 0 0 var(--radius); }
  .toolbar .btn-group button:last-child { border-radius: 0 var(--radius) var(--radius) 0; }
  .toolbar .btn-solo {
    border-radius: var(--radius); background: var(--bg-surface);
    border: 1px solid var(--border);
  }
  .toggle-sidebar {
    background: var(--bg-surface) !important;
    border: 1px solid var(--border) !important;
    border-radius: var(--radius) !important;
    padding: 5px 10px !important;
    font-size: 12px !important;
  }
  .fit-group {
    display: inline-flex; align-items: stretch; gap: 0;
    border-radius: var(--radius); overflow: hidden;
    border: 1px solid var(--border);
  }
  .fit-group .fit-btn {
    border: none !important; border-radius: 0 !important;
    padding: 5px 10px !important;
  }
  .auto-fit-toggle {
    display: flex; align-items: center; justify-content: center;
    width: 26px; cursor: pointer;
    background: var(--bg-surface); border-left: 1px solid var(--border);
    transition: background .12s;
  }
  .auto-fit-toggle:hover { background: #1e2345; }
  .auto-fit-toggle input { display: none; }
  .auto-fit-check {
    font-size: 11px; color: var(--text-muted); transition: color .12s;
  }
  .auto-fit-toggle input:checked ~ .auto-fit-check {
    color: var(--green);
  }
  .toolbar .zoom-label {
    color: var(--text-muted); font-size: 11px;
    font-family: var(--mono); min-width: 36px; text-align: center;
  }
  .toolbar .sep {
    width: 1px; height: 20px; background: var(--border); margin: 0 6px;
  }

  /* ── Node Size Slider ── */
  .size-control {
    display: flex; align-items: center; gap: 8px;
    margin-left: 4px;
  }
  .size-control label {
    font-size: 10px; text-transform: uppercase; letter-spacing: 0.8px;
    color: var(--text-muted); font-weight: 500; white-space: nowrap;
  }
  .size-control input[type="range"] {
    -webkit-appearance: none; appearance: none;
    width: 80px; height: 3px; border-radius: 2px;
    background: var(--bg-surface); outline: none;
    cursor: pointer;
  }
  .size-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 12px; height: 12px; border-radius: 50%;
    background: var(--accent); border: 2px solid var(--bg-panel);
    cursor: pointer; transition: box-shadow .15s;
  }
  .size-control input[type="range"]::-webkit-slider-thumb:hover {
    box-shadow: 0 0 0 3px var(--accent-glow);
  }
  .size-control input[type="range"]::-moz-range-thumb {
    width: 12px; height: 12px; border-radius: 50%;
    background: var(--accent); border: 2px solid var(--bg-panel);
    cursor: pointer;
  }
  .size-control .size-val {
    font-size: 10px; color: var(--text-muted);
    font-family: var(--mono); min-width: 24px;
  }

  /* ── Legend ── */
  .legend {
    display: flex; flex-wrap: wrap; gap: 10px; margin-left: auto;
    font-size: 10px; color: var(--text-secondary);
  }
  .legend-item { display: flex; align-items: center; gap: 4px; }
  .legend-swatch {
    width: 8px; height: 8px; border-radius: 2px; display: inline-block;
  }

  /* ── Canvas ── */
  #cy {
    flex: 1; overflow: hidden;
    background:
      radial-gradient(circle at 50% 0%, rgba(76,141,255,0.03) 0%, transparent 60%),
      var(--bg-deep);
  }

  /* ── Loading ── */
  #loading {
    display: flex; align-items: center; justify-content: center;
    flex: 1; color: var(--text-muted); font-size: 14px;
  }
  #loading.hidden { display: none; }
  #error-msg {
    color: var(--red); font-size: 12px; padding: 20px;
    text-align: center; display: none;
  }

  /* ── Hints ── */
  .hint {
    position: fixed; bottom: 10px; right: 16px;
    color: var(--text-muted); font-size: 10px;
    font-family: var(--mono); opacity: 0.7;
  }
  .sp-link {
    display: inline-flex; align-items: center; justify-content: center;
    width: 16px; height: 16px; flex-shrink: 0; margin-left: auto;
    color: var(--text-muted); opacity: 0.6; transition: opacity .15s, color .15s;
    text-decoration: none;
  }
  .sp-link:hover { opacity: 1; color: var(--accent); }
  .sp-link svg { width: 12px; height: 12px; }

  /* ── Detail Panel ── */
  #detail-panel {
    width: 320px; min-width: 200px; max-width: 50vw;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: none; flex-direction: column;
    overflow: hidden; flex-shrink: 0;
    position: relative;
  }
  #detail-panel.open { display: flex; }
  #detail-panel .detail-resize {
    position: absolute; left: -3px; top: 0; bottom: 0;
    width: 6px; cursor: col-resize; z-index: 10;
  }
  #detail-panel .detail-resize:hover,
  #detail-panel .detail-resize.dragging {
    background: var(--accent-glow);
  }
  .detail-header {
    padding: 14px 16px; font-size: 11px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.2px;
    color: var(--text-secondary);
    border-bottom: 1px solid var(--border);
    display: flex; justify-content: space-between; align-items: center;
    flex-shrink: 0;
  }
  .detail-header button {
    background: none; border: none; color: var(--text-muted);
    cursor: pointer; font-size: 15px; line-height: 1;
    transition: color .15s;
  }
  .detail-header button:hover { color: var(--text-primary); }
  #detail-body {
    flex: 1; overflow: hidden; padding: 16px;
    display: flex; flex-direction: column;
  }
  #detail-body.no-knowledge {
    overflow-y: auto;
  }
  #detail-body::-webkit-scrollbar { width: 4px; }
  #detail-body::-webkit-scrollbar-track { background: transparent; }
  #detail-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 4px; }
  .detail-name {
    font-size: 16px; font-weight: 600; color: #fff;
    margin-bottom: 2px; line-height: 1.3;
  }
  .detail-title {
    font-size: 12px; color: var(--text-secondary);
    margin-bottom: 12px; line-height: 1.4;
  }
  .detail-section {
    margin-bottom: 14px;
  }
  .detail-section h4 {
    font-size: 9px; text-transform: uppercase; letter-spacing: 1.5px;
    color: var(--text-muted); margin-bottom: 6px; font-weight: 500;
  }
  .detail-section .detail-val {
    font-size: 12px; color: var(--text-primary); line-height: 1.5;
  }
  .detail-section a {
    color: var(--accent); text-decoration: none;
    transition: color .15s;
  }
  .detail-section a:hover { color: var(--accent-hover); text-decoration: underline; }
  .detail-badge {
    display: inline-block; padding: 2px 8px;
    background: var(--bg-surface); border: 1px solid var(--border);
    border-radius: 10px; font-size: 10px; color: var(--text-secondary);
    margin: 2px 4px 2px 0;
  }
  .detail-badge.confidence-high { border-color: var(--green); color: var(--green); }
  .detail-badge.confidence-medium { border-color: var(--orange); color: var(--orange); }
  .detail-badge.confidence-low { border-color: var(--red); color: var(--red); }
  .detail-signals {
    font-size: 11.5px; color: var(--text-secondary); line-height: 1.55;
    white-space: pre-wrap;
  }
  .detail-prog-header {
    font-size: 14px; font-weight: 600; color: var(--green);
    margin-bottom: 2px; line-height: 1.3;
  }
  .detail-status {
    display: inline-block; padding: 3px 10px;
    background: var(--green-dim); border: 1px solid rgba(92,224,160,0.25);
    border-radius: 10px; font-size: 11px; color: var(--green);
    margin-bottom: 12px;
  }
  .detail-contact-chip {
    display: inline-block; padding: 3px 10px;
    background: var(--bg-surface); border: 1px solid var(--border);
    border-radius: 10px; font-size: 11px; color: var(--accent);
    margin: 2px 4px 2px 0; cursor: pointer;
    transition: border-color .15s, color .15s;
  }
  .detail-contact-chip:hover {
    border-color: var(--accent); color: var(--accent-hover);
  }
  .doc-badge {
    display: inline-block; padding: 1px 6px;
    background: rgba(76,141,255,0.12); border: 1px solid rgba(76,141,255,0.25);
    border-radius: 8px; font-size: 9px; color: var(--accent);
    margin-left: 6px; font-family: var(--mono); font-weight: 500;
    vertical-align: middle;
  }
  .ws-clickable { cursor: pointer; }
  .ws-clickable:hover .doc-badge {
    background: rgba(76,141,255,0.2); border-color: var(--accent);
  }
  .doc-item {
    display: flex; align-items: center; gap: 8px;
    padding: 6px 0; font-size: 12px; color: var(--text-primary);
    border-bottom: 1px solid var(--border);
  }
  .doc-item:last-child { border-bottom: none; }
  .doc-icon {
    font-size: 10px; font-family: var(--mono); font-weight: 600;
    color: var(--text-muted); min-width: 32px; text-align: center;
    text-transform: uppercase;
  }
  .doc-meta {
    font-size: 10px; color: var(--text-muted); margin-left: auto;
    white-space: nowrap;
  }
  .knowledge-section {
    margin-top: 14px; border-top: 1px solid var(--border); padding-top: 12px;
    display: flex; flex-direction: column; flex: 1; min-height: 0;
  }
  .knowledge-scroll {
    flex: 1; overflow-y: auto; min-height: 0;
    border: 1px solid var(--border); border-radius: var(--radius);
    background: var(--bg-deep); padding: 0;
  }
  .knowledge-scroll::-webkit-scrollbar { width: 4px; }
  .knowledge-scroll::-webkit-scrollbar-track { background: transparent; }
  .knowledge-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }
  .k-entry {
    padding: 10px 12px; border-bottom: 1px solid var(--border);
    transition: background .1s;
  }
  .k-entry:last-child { border-bottom: none; }
  .k-entry:hover { background: rgba(255,255,255,0.02); }
  .k-type {
    display: inline-block; padding: 1px 6px;
    border-radius: 3px; font-size: 9px; font-weight: 600;
    font-family: var(--mono); letter-spacing: 0.5px;
    text-transform: uppercase; margin-right: 6px;
    vertical-align: middle;
  }
  .k-type-decision { background: rgba(76,141,255,0.15); color: var(--accent); }
  .k-type-technical { background: rgba(92,224,160,0.12); color: var(--green); }
  .k-type-status { background: rgba(245,166,35,0.12); color: var(--orange); }
  .k-type-action { background: rgba(255,107,122,0.12); color: var(--red); }
  .k-type-blocker { background: rgba(255,107,122,0.2); color: var(--red); }
  .k-type-timeline, .k-type-budget, .k-type-risk {
    background: rgba(245,166,35,0.12); color: var(--orange);
  }
  .k-summary {
    font-size: 12px; color: var(--text-primary); line-height: 1.4;
    display: inline; vertical-align: middle;
  }
  .k-detail {
    font-size: 11px; color: var(--text-secondary); line-height: 1.45;
    margin-top: 4px;
  }
  .k-meta {
    font-size: 10px; color: var(--text-muted); margin-top: 3px;
    font-family: var(--mono);
  }
  .k-count-badge {
    display: inline-block; padding: 1px 6px;
    background: rgba(92,224,160,0.12); border: 1px solid rgba(92,224,160,0.25);
    border-radius: 8px; font-size: 9px; color: var(--green);
    margin-left: 6px; font-family: var(--mono); font-weight: 500;
    vertical-align: middle;
  }
  .hint kbd {
    display: inline-block; padding: 1px 4px;
    background: var(--bg-surface); border: 1px solid var(--border);
    border-radius: 3px; font-size: 9px; margin: 0 1px;
  }
</style>
</head>
<body>

<div id="sidebar">
  <div class="sidebar-header">
    <span>Filters</span>
    <button onclick="toggleSidebar()" title="Close">&times;</button>
  </div>
  <div id="filter-content"></div>
  <button class="reset-btn" onclick="resetFilters()">Reset All</button>
</div>

<div id="main">
  <header>
    <h1 id="company-title">{{COMPANY_NAME}}</h1>
    <div class="subtitle" id="subtitle">Loading...</div>
  </header>
  <div class="toolbar">
    <button class="toggle-sidebar btn-solo" onclick="toggleSidebar()">&#9776; Filters</button>
    <div class="sep"></div>
    <div class="btn-group">
      <button onclick="zoomIn()">+</button>
      <button onclick="zoomOut()">&minus;</button>
    </div>
    <span class="zoom-label" id="zoom-label">100%</span>
    <span class="fit-group">
      <button class="btn-solo fit-btn" onclick="resetView()">Fit</button><label class="auto-fit-toggle" title="Auto-fit after filter or drag"><input type="checkbox" id="auto-fit-cb" checked onchange="window._toggleAutoFit(this.checked)"><span class="auto-fit-check">&#10003;</span></label>
    </span>
    <button class="btn-solo" onclick="reLayout()">Re-layout</button>
    <div class="sep"></div>
    <div class="size-control">
      <label>Node size</label>
      <input type="range" id="node-size" min="40" max="200" value="100" step="5" oninput="window._onNodeSize(this.value)">
      <span class="size-val" id="size-val">100%</span>
    </div>
    <div class="size-control">
      <label>Text size</label>
      <input type="range" id="text-size" min="50" max="200" value="100" step="5" oninput="window._onTextSize(this.value)">
      <span class="size-val" id="text-size-val">100%</span>
    </div>
    <div class="legend">
      <div class="legend-item"><span class="legend-swatch" style="background:#1a365d"></span>CEO</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#2b4a7a"></span>C-Suite</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#2c7ac9"></span>VP</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#3182ce"></span>Dir</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#4299e1"></span>Mgr</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#bee3f8;border:1px solid #4299e1"></span>IC</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#e2e8f0;border:1px dashed #999"></span>Ctr</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#fefcbf;border:1px dashed #d69e2e"></span>TBD</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#fbd38d"></span>Ext</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#fc8181"></span>Intel</div>
      <div class="legend-item"><span class="legend-swatch" style="background:#68d391"></span>Prog</div>
    </div>
  </div>
  <div id="loading">Loading org chart data...</div>
  <div id="error-msg"></div>
  <div id="cy" style="display:none"></div>
</div>

<div id="detail-panel">
  <div class="detail-resize" id="detail-resize"></div>
  <div class="detail-header">
    <span id="detail-header-label">Details</span>
    <button onclick="closeDetail()" title="Close">&times;</button>
  </div>
  <div id="detail-body"></div>
</div>

<div class="hint">Scroll&thinsp;=&thinsp;zoom &middot; Drag&thinsp;=&thinsp;pan &middot; Drag nodes to rearrange &middot; <kbd>+</kbd><kbd>-</kbd><kbd>0</kbd></div>

{{EMBEDDED_DATA}}
<script src="https://unpkg.com/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
<script src="https://unpkg.com/layout-base/layout-base.js"></script>
<script src="https://unpkg.com/cose-base/cose-base.js"></script>
<script src="https://unpkg.com/cytoscape-fcose/cytoscape-fcose.js"></script>
<script>
document.addEventListener('DOMContentLoaded', async function() {

// ==================== LOAD ORG CHART DATA ====================

// Use embedded data if available, otherwise fetch from files
let orgData = window.__EMBEDDED_ORG_DATA__ || null;
let engagementMap = window.__EMBEDDED_ENGAGEMENT_MAP__ || null;
let fileIndex = window.__EMBEDDED_FILE_INDEX__ || null;
let knowledgeEntries = window.__EMBEDDED_KNOWLEDGE__ || null;

if (!orgData) {
  try {
    const resp = await fetch('./org_chart.json');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
    orgData = await resp.json();
  } catch(err) {
    document.getElementById('loading').classList.add('hidden');
    const errEl = document.getElementById('error-msg');
    errEl.style.display = 'block';
    errEl.textContent = `Failed to load org_chart.json: ${err.message}. Make sure this file is served from a web server (not file://), or regenerate the viewer with sl-ot-tools generate-viewer.`;
    return;
  }
}

if (!engagementMap) {
  try {
    const resp2 = await fetch('./engagement_map.json');
    if (resp2.ok) engagementMap = await resp2.json();
  } catch(e) { /* ignore — will use program-based fallback */ }
}

document.getElementById('loading').classList.add('hidden');
document.getElementById('cy').style.display = 'block';

// ==================== TRANSFORM ORG CHART ====================

const transformed = transformOrgChart(orgData);
const NODES = transformed.nodes;
const REPORTING = transformed.reporting;
const REPORT_STYLES = transformed.reportStyles;
const INTERNAL_DOTTED = transformed.internalDotted;
const DOTTED_STYLES = transformed.dottedStyles;
const SUBGRAPHS = transformed.subgraphs;
const AFFILIATIONS = transformed.affiliations;
const PROGRAM_LINKS = transformed.programLinks;
const PROGRAM_TREE = transformed.programTree;
const PROGRAM_BOXES = transformed.programBoxes;
const ORG_LIST = transformed.orgList;

function transformOrgChart(data) {
  // The org chart JSON has a well-defined schema.
  // If the data already has a "viewer" key with pre-built structures, use those directly.
  if (data.viewer) return data.viewer;

  // Otherwise, build from the standard org_chart.json format.
  // This handles the Altera-style org chart with leadership/people arrays
  // and external_ecosystem/key_programs sections.
  const nodes = {};
  const reporting = [];
  const reportStyles = [];
  const internalDotted = [];
  const dottedStyles = [];
  const subgraphs = {};
  const affiliations = [];
  const programLinks = [];
  const programTree = [];
  const programBoxes = [];
  const orgList = [];

  const clsMap = {
    'CEO': 'ceo', 'C-Suite': 'csuite', 'CxO': 'csuite',
    'VP': 'vp', 'SVP': 'vp', 'EVP': 'vp',
    'Director': 'director', 'Sr Director': 'director', 'Senior Director': 'director',
    'Manager': 'manager', 'Sr Manager': 'manager',
    'IC': 'ic', 'Engineer': 'ic', 'Staff': 'ic',
    'Contractor': 'contractor', 'Unknown': 'unknown'
  };

  function truncLine(str, max) {
    if (!str) return '';
    str = str.trim();
    return str.length > max ? str.slice(0, max - 1) + '\u2026' : str;
  }

  function buildLabel(name, title, comment) {
    const lines = [truncLine(name, 22)];
    if (title) lines.push(truncLine(title, 26));
    if (comment) lines.push(truncLine(comment, 26));
    return lines.join('\n');
  }

  function makeId(name) {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/(^_|_$)/g, '');
  }

  function inferCls(title, level) {
    if (level) {
      const l = level.toLowerCase();
      if (clsMap[level]) return clsMap[level];
    }
    if (!title) return 'unknown';
    const t = title.toLowerCase();
    if (/\bceo\b/.test(t)) return 'ceo';
    if (/\b(cfo|cto|cio|coo|cmo|svp\s+|evp\s+|general\s+counsel)\b/.test(t)) return 'csuite';
    if (/\b(vp|vice\s+president)\b/i.test(t)) return 'vp';
    if (/\b(director|sr\.?\s+dir)\b/i.test(t)) return 'director';
    if (/\b(manager|team\s+lead)\b/i.test(t)) return 'manager';
    if (/\bcontract/i.test(t)) return 'contractor';
    return 'ic';
  }

  // Build people nodes from leadership + people arrays
  const companyName = data.company || data.meta?.company?.name || data.organization?.name || '{{COMPANY_NAME}}';
  const companyDomain = (data.company || data.meta?.company?.name || 'company').toLowerCase().replace(/\s+/g, '_');

  // Process internal people
  for (const section of ['leadership', 'people', 'team']) {
    if (!data[section]) continue;
    for (const person of data[section]) {
      const id = makeId(person.name);
      const progs = person.programs || [];
      const comment = person.confidence ? person.confidence : '';
      nodes[id] = {
        label: buildLabel(person.name, person.title, comment),
        org: companyDomain,
        progs: progs,
        email: person.email || '',
        cls: inferCls(person.title, person.level),
        _person: person
      };
      if (person.reports_to) {
        const cleanReportsTo = person.reports_to.replace(/\s*\(.*?\)\s*$/, '');
        const parentId = makeId(cleanReportsTo);
        if (parentId !== id) {
          reporting.push([parentId, id]);
          reportStyles.push('stroke:#93c5fd,stroke-width:2px');
        }
      }
      if (person.dotted_to) {
        const cleanDottedTo = person.dotted_to.replace(/\s*\(.*?\)\s*$/, '');
        const parentId = makeId(cleanDottedTo);
        if (parentId !== id) {
          internalDotted.push([parentId, id]);
          dottedStyles.push('stroke:#94a3b8,stroke-width:1px');
        }
      }
    }
  }

  // Process external ecosystem
  // Supports both nested format (orgType -> orgs -> contacts) and flat format (orgKey -> {key_contacts})
  if (data.external_ecosystem) {
    function processExtOrg(orgKey, orgData_, parentKey) {
      if (!orgData_ || typeof orgData_ !== 'object') return;
      if (orgData_.key_contacts) {
        // This is an org with contacts
        const orgLabel = orgData_.name || orgKey;
        const orgId = makeId(orgKey);
        const members = [];
        for (const person of orgData_.key_contacts) {
          const id = makeId(person.name);
          nodes[id] = {
            label: buildLabel(person.name, person.title, person.notes),
            org: orgId,
            progs: person.programs || [],
            email: person.email || '',
            cls: orgKey === 'intel' ? 'intel' : 'exPerson',
            _person: person
          };
          members.push(id);
          if (person.affiliations) {
            for (const aff of person.affiliations) {
              affiliations.push({
                from: id, to: makeId(aff.with),
                label: aff.label || '', prog: aff.program || ''
              });
            }
          }
        }
        if (members.length > 0) {
          const color = orgKey === 'intel' ? '#fc8181' : '#fbd38d';
          subgraphs[orgId.toUpperCase()] = {
            label: orgData_.relationship ? `${orgLabel} (${orgData_.relationship})` : orgLabel,
            org: orgId, members, edges: []
          };
          orgList.push({ key: orgId, label: orgLabel, color });
        }
      } else {
        // Nested: this level contains sub-orgs
        for (const [subKey, subData] of Object.entries(orgData_)) {
          if (typeof subData === 'object') processExtOrg(subKey, subData, orgKey);
        }
      }
    }
    for (const [key, val] of Object.entries(data.external_ecosystem)) {
      if (typeof val !== 'object') continue;
      processExtOrg(key, val, null);
    }
  }

  // Process programs — supports both array format and dict format
  if (data.key_programs) {
    // Normalize to array of {key, name, ...}
    let progArray;
    if (Array.isArray(data.key_programs)) {
      progArray = data.key_programs;
    } else {
      progArray = Object.entries(data.key_programs).map(([k, v]) => ({
        key: k, name: v.description || k, ...v
      }));
    }

    // Build reverse map: program -> people (from key_altera_contacts)
    const progToPeople = {};
    const progBoxSet = new Set(); // track added program box keys to avoid duplicates

    // Pass 1: create all program boxes (no duplicates)
    for (const prog of progArray) {
      const progKey = prog.key || makeId(prog.name);
      const progId = progKey + '_p';
      if (!progBoxSet.has(progKey)) {
        progBoxSet.add(progKey);
        programBoxes.push({ key: progKey, id: progId, label: prog.name || progKey, _prog: prog });
      }
    }

    // Pass 2: build tree structure and program links
    for (const prog of progArray) {
      const progKey = prog.key || makeId(prog.name);
      const progId = progKey + '_p';

      const children = [];
      const subProgs = prog.sub_programs || [];
      if (Array.isArray(subProgs)) {
        for (const sub of subProgs) {
          const subKey = typeof sub === 'string' ? sub : (sub.key || makeId(sub.name));
          const subObj = typeof sub === 'string'
            ? progArray.find(p => p.key === sub) || { key: sub, name: sub }
            : sub;
          children.push({ key: subKey, label: subObj.name || subKey });
        }
      }

      // Skip programs that are sub-programs of another (they're children, not top-level)
      if (!prog.parent) {
        programTree.push({ key: progKey, label: prog.name || progKey, children });
      }

      // Program contacts -> links + reverse map
      if (prog.key_altera_contacts) {
        for (const contact of prog.key_altera_contacts) {
          programLinks.push([progId, makeId(contact), progKey]);
          if (!progToPeople[progKey]) progToPeople[progKey] = [];
          progToPeople[progKey].push(makeId(contact));
        }
      }
    }

    // Reverse-map: assign programs to people who don't already have them
    for (const [progKey, personIds] of Object.entries(progToPeople)) {
      for (const pid of personIds) {
        if (nodes[pid] && !nodes[pid].progs.includes(progKey)) {
          nodes[pid].progs.push(progKey);
        }
      }
    }
  }

  return {
    nodes, reporting, reportStyles, internalDotted, dottedStyles,
    subgraphs, affiliations, programLinks, programTree, programBoxes, orgList
  };
}

// ==================== DERIVED SETS ====================

const ALL_PROG_KEYS = new Set();
PROGRAM_TREE.forEach(p => { ALL_PROG_KEYS.add(p.key); p.children.forEach(c => ALL_PROG_KEYS.add(c.key)); });

const PROG_BOX_IDS = new Set(PROGRAM_BOXES.map(p => p.id));

const CLASS_COLORS = {
  ceo:        { bg:'#1a365d', text:'#fff', border:'#2a4a7a' },
  csuite:     { bg:'#2b4a7a', text:'#fff', border:'#3a5a8a' },
  vp:         { bg:'#2c7ac9', text:'#fff', border:'#4090dd' },
  director:   { bg:'#3182ce', text:'#fff', border:'#4a96dd' },
  manager:    { bg:'#4299e1', text:'#fff', border:'#5aabe8' },
  ic:         { bg:'#bee3f8', text:'#1a365d', border:'#4299e1' },
  contractor: { bg:'#e2e8f0', text:'#333', border:'#999' },
  unknown:    { bg:'#fefcbf', text:'#744210', border:'#d69e2e' },
  exPerson:   { bg:'#fbd38d', text:'#744210', border:'#dd6b20' },
  intel:      { bg:'#fc8181', text:'#fff', border:'#e53e3e' },
  program:    { bg:'#68d391', text:'#1a365d', border:'#38a169' }
};

// ==================== NODE SIZE STATE ====================

const BASE_W = 90, BASE_H = 36, BASE_FONT = 7;
let nodeScale = 1.0;
let textScale = 1.0;

function getNodeDims() {
  return {
    w: BASE_W * nodeScale,
    h: BASE_H * nodeScale,
    font: Math.max(6, BASE_FONT * nodeScale * textScale),
    maxText: (BASE_W - 10) * nodeScale * textScale
  };
}

// ==================== FILTER STATE ====================

let activeOrgs = new Set(ORG_LIST.map(o => o.key));
let activePrograms = new Set(ALL_PROG_KEYS);

// Engagement filter state (populated if engagementMap is available)
const ENGAGEMENT_DATA = engagementMap ? engagementMap.engagements : [];
const ALL_WS_KEYS = new Set();
ENGAGEMENT_DATA.forEach(e => e.workstreams.forEach(ws => ALL_WS_KEYS.add(e.key + '/' + ws.key)));
let activeWorkstreams = new Set(ALL_WS_KEYS);
const useEngagements = ENGAGEMENT_DATA.length > 0;

// File index: build document count per workstream
const DOC_COUNTS = {};  // "eng/ws" -> count
const DOC_BY_WS = {};   // "eng/ws" -> [file entries]
if (fileIndex && fileIndex.files) {
  for (const f of fileIndex.files) {
    if (!f.is_primary) continue;
    const key = (f.engagement || '') + '/' + (f.workstream || 'unclassified');
    DOC_COUNTS[key] = (DOC_COUNTS[key] || 0) + 1;
    if (!DOC_BY_WS[key]) DOC_BY_WS[key] = [];
    DOC_BY_WS[key].push(f);
  }
}

// Knowledge: build indexes by program and by workstream
const KNOWLEDGE_BY_PROG = {};   // program_key -> [entries]
const KNOWLEDGE_BY_WS = {};     // "eng/ws" -> [entries]
if (knowledgeEntries && Array.isArray(knowledgeEntries)) {
  for (const k of knowledgeEntries) {
    const wsKey = (k.engagement || '') + '/' + (k.workstream || '');
    if (!KNOWLEDGE_BY_WS[wsKey]) KNOWLEDGE_BY_WS[wsKey] = [];
    KNOWLEDGE_BY_WS[wsKey].push(k);
    for (const prog of (k.programs || [])) {
      if (!KNOWLEDGE_BY_PROG[prog]) KNOWLEDGE_BY_PROG[prog] = [];
      KNOWLEDGE_BY_PROG[prog].push(k);
    }
  }
}

function syncProgs() {
  activePrograms.clear();
  for (const parent of PROGRAM_TREE) {
    if (parent.children.length === 0) {
      if (document.getElementById('prog-' + parent.key).checked) activePrograms.add(parent.key);
    } else {
      let any = false;
      for (const child of parent.children) {
        if (document.getElementById('prog-' + child.key).checked) { activePrograms.add(child.key); any = true; }
      }
      if (any) activePrograms.add(parent.key);
    }
  }
}

function syncOrgs() {
  activeOrgs.clear();
  for (const o of ORG_LIST) {
    if (document.getElementById('org-' + o.key).checked) activeOrgs.add(o.key);
  }
}

function syncEngagements() {
  activeWorkstreams.clear();
  activePrograms.clear();
  for (const eng of ENGAGEMENT_DATA) {
    let anyWs = false;
    for (const ws of eng.workstreams) {
      const wsFullKey = eng.key + '/' + ws.key;
      const el = document.getElementById('ws-' + wsFullKey);
      if (el && el.checked) {
        activeWorkstreams.add(wsFullKey);
        anyWs = true;
        for (const p of ws.programs) activePrograms.add(p);
      }
    }
    // Update parent checkbox state
    const engEl = document.getElementById('eng-' + eng.key);
    if (engEl) {
      const allChecked = eng.workstreams.every(ws => {
        const el = document.getElementById('ws-' + eng.key + '/' + ws.key);
        return el && el.checked;
      });
      engEl.checked = allChecked;
      engEl.indeterminate = !allChecked && anyWs;
    }
  }
}

window._onOrg = function() { syncOrgs(); scheduleRender(); };

window._onParent = function(key) {
  const parent = PROGRAM_TREE.find(p => p.key === key);
  const checked = document.getElementById('prog-' + key).checked;
  for (const c of parent.children) document.getElementById('prog-' + c.key).checked = checked;
  syncProgs(); scheduleRender();
};

window._onChild = function(parentKey) {
  const parent = PROGRAM_TREE.find(p => p.key === parentKey);
  const all = parent.children.every(c => document.getElementById('prog-' + c.key).checked);
  const any = parent.children.some(c => document.getElementById('prog-' + c.key).checked);
  const pcb = document.getElementById('prog-' + parentKey);
  pcb.checked = all; pcb.indeterminate = !all && any;
  syncProgs(); scheduleRender();
};

window._onStandalone = function() { syncProgs(); scheduleRender(); };

window._onEngagement = function(engKey) {
  const eng = ENGAGEMENT_DATA.find(e => e.key === engKey);
  const checked = document.getElementById('eng-' + engKey).checked;
  for (const ws of eng.workstreams) {
    const el = document.getElementById('ws-' + engKey + '/' + ws.key);
    if (el) el.checked = checked;
  }
  syncEngagements(); scheduleRender();
};

window._onWorkstream = function(engKey) {
  syncEngagements(); scheduleRender();
};

// ==================== VISIBILITY ====================

// Detect the "internal" org key (the main company)
const internalOrgKey = Object.keys(NODES).length > 0
  ? Object.values(NODES)[0].org
  : 'company';

// Build parent/child maps for smart filtering
const parentMap = {};  // child -> parent
const childMap = {};   // parent -> [children]
for (const [f, t] of REPORTING) {
  parentMap[t] = f;
  if (!childMap[f]) childMap[f] = [];
  childMap[f].push(t);
}

function getVisible() {
  const vis = new Set();
  const allProgsOn = useEngagements
    ? activeWorkstreams.size === ALL_WS_KEYS.size
    : activePrograms.size === ALL_PROG_KEYS.size;

  if (allProgsOn) {
    // All filters on — show everyone (original behavior)
    for (const [id, n] of Object.entries(NODES)) {
      if (n.org === internalOrgKey) { vis.add(id); continue; }
      if (!activeOrgs.has(n.org)) continue;
      vis.add(id);
    }
    return vis;
  }

  if (useEngagements) {
    // Smart filtering: collect people_associations emails from selected workstreams
    const assocEmails = new Set();
    for (const eng of ENGAGEMENT_DATA) {
      for (const ws of eng.workstreams) {
        if (activeWorkstreams.has(eng.key + '/' + ws.key)) {
          for (const email of (ws.people_associations || [])) {
            assocEmails.add(email.toLowerCase());
          }
        }
      }
    }

    // Find directly matched internal people (by program or email association)
    const directMatch = new Set();
    for (const [id, n] of Object.entries(NODES)) {
      if (n.org !== internalOrgKey) continue;
      if (n.progs.some(p => activePrograms.has(p))) { directMatch.add(id); continue; }
      if (n.email && assocEmails.has(n.email.toLowerCase())) { directMatch.add(id); }
    }

    // Expand: include 1 level up (direct manager) and 1 level down (direct reports)
    for (const id of directMatch) {
      vis.add(id);
      // One level up
      if (parentMap[id]) vis.add(parentMap[id]);
      // One level down
      if (childMap[id]) {
        for (const child of childMap[id]) vis.add(child);
      }
    }
  } else {
    // Legacy program-based filtering: internals always visible
    for (const [id, n] of Object.entries(NODES)) {
      if (n.org === internalOrgKey) { vis.add(id); continue; }
    }
  }

  // External people: filter by org + program intersection (same as before)
  for (const [id, n] of Object.entries(NODES)) {
    if (n.org === internalOrgKey) continue;
    if (!activeOrgs.has(n.org)) continue;
    if (n.progs.some(p => activePrograms.has(p))) vis.add(id);
  }

  return vis;
}

// ==================== BUILD CYTOSCAPE ELEMENTS ====================

function parseStyle(styleStr) {
  const color = (styleStr.match(/stroke:(#[0-9a-fA-F]+)/) || [])[1] || '#fff';
  const width = parseFloat((styleStr.match(/stroke-width:([\d.]+)/) || [])[1] || '2');
  return { color, width };
}

function buildElements() {
  const nodes = [];
  const edges = [];

  for (const [sgId, sg] of Object.entries(SUBGRAPHS)) {
    nodes.push({
      data: { id: 'group_' + sgId, label: sg.label, nodeType: 'compound', org: sg.org },
      classes: 'compound'
    });
  }

  if (PROGRAM_BOXES.length > 0) {
    nodes.push({
      data: { id: 'group_PROGRAMS', label: 'Key Programs', nodeType: 'compound', org: 'programs' },
      classes: 'compound compound-programs'
    });
  }

  for (const [id, n] of Object.entries(NODES)) {
    const data = { id, label: n.label, cls: n.cls, org: n.org, progs: n.progs, nodeType: 'person', _person: n._person || {} };
    for (const [sgId, sg] of Object.entries(SUBGRAPHS)) {
      if (sg.members.includes(id)) {
        data.parent = 'group_' + sgId;
        break;
      }
    }
    nodes.push({ data, classes: n.cls });
  }

  for (const p of PROGRAM_BOXES) {
    nodes.push({
      data: { id: p.id, label: p.label, cls: 'program', nodeType: 'program', progKey: p.key, parent: 'group_PROGRAMS', _prog: p._prog || {} },
      classes: 'program'
    });
  }

  // Collect all valid node IDs to skip dangling edges
  const nodeIds = new Set(nodes.map(n => n.data.id));

  for (let i = 0; i < REPORTING.length; i++) {
    const [f, t] = REPORTING[i];
    if (!nodeIds.has(f) || !nodeIds.has(t)) continue;
    const s = parseStyle(REPORT_STYLES[i] || 'stroke:#93c5fd,stroke-width:2px');
    edges.push({
      data: { id: 'report_' + i, source: f, target: t, edgeType: 'reporting', lineColor: s.color, lineWidth: s.width },
      classes: 'reporting'
    });
  }

  for (let i = 0; i < INTERNAL_DOTTED.length; i++) {
    const [f, t] = INTERNAL_DOTTED[i];
    if (!nodeIds.has(f) || !nodeIds.has(t)) continue;
    const s = parseStyle(DOTTED_STYLES[i] || 'stroke:#94a3b8,stroke-width:1px');
    edges.push({
      data: { id: 'dotted_' + i, source: f, target: t, edgeType: 'internal_dotted', lineColor: s.color, lineWidth: s.width },
      classes: 'internal-dotted'
    });
  }

  let sgEdgeIdx = 0;
  for (const [sgId, sg] of Object.entries(SUBGRAPHS)) {
    for (const [f, t] of (sg.edges || [])) {
      if (!nodeIds.has(f) || !nodeIds.has(t)) continue;
      edges.push({
        data: { id: 'sg_' + sgEdgeIdx++, source: f, target: t, edgeType: 'subgraph_internal', lineColor: '#fca5a5', lineWidth: 1.5 },
        classes: 'subgraph-internal'
      });
    }
  }

  for (let i = 0; i < AFFILIATIONS.length; i++) {
    const a = AFFILIATIONS[i];
    if (!nodeIds.has(a.from) || !nodeIds.has(a.to)) continue;
    edges.push({
      data: { id: 'affil_' + i, source: a.from, target: a.to, edgeType: 'affiliation', lineColor: '#6b7280', lineWidth: 1, label: a.label, prog: a.prog },
      classes: 'affiliation'
    });
  }

  for (let i = 0; i < PROGRAM_LINKS.length; i++) {
    const [f, t, prog] = PROGRAM_LINKS[i];
    if (!nodeIds.has(f) || !nodeIds.has(t)) continue;
    edges.push({
      data: { id: 'plink_' + i, source: f, target: t, edgeType: 'program_link', lineColor: '#68d391', lineWidth: 1.5, prog },
      classes: 'program-link'
    });
  }

  return { nodes, edges };
}

// ==================== COMPUTE HIERARCHY DEPTHS ====================

function computeDepths() {
  // Find root node (node that is a source but never a target in REPORTING)
  const targets = new Set(REPORTING.map(r => r[1]));
  let root = null;
  for (const [f, _] of REPORTING) {
    if (!targets.has(f)) { root = f; break; }
  }
  if (!root && Object.keys(NODES).length > 0) root = Object.keys(NODES)[0];

  const depths = {};
  if (root) depths[root] = 0;

  const childMap = {};
  for (const [f, t] of REPORTING) {
    if (!childMap[f]) childMap[f] = [];
    childMap[f].push(t);
  }
  for (const [f, t] of INTERNAL_DOTTED) {
    if (!childMap[f]) childMap[f] = [];
    childMap[f].push(t);
  }
  const queue = root ? [root] : [];
  while (queue.length) {
    const node = queue.shift();
    for (const child of (childMap[node] || [])) {
      if (depths[child] === undefined) {
        depths[child] = depths[node] + 1;
        queue.push(child);
      }
    }
  }
  return depths;
}

// ==================== CYTOSCAPE STYLESHEET ====================

function buildStylesheet() {
  const d = getNodeDims();
  const styles = [
    {
      selector: 'node',
      style: {
        'label': 'data(label)',
        'text-wrap': 'wrap',
        'text-valign': 'center',
        'text-halign': 'center',
        'font-size': d.font + 'px',
        'font-family': 'DM Sans, system-ui, sans-serif',
        'width': d.w + 'px',
        'height': d.h + 'px',
        'shape': 'round-rectangle',
        'border-width': 1.5,
        'text-max-width': d.maxText + 'px',
        'padding': '6px'
      }
    },
    {
      selector: '.compound',
      style: {
        'background-color': '#ffffff',
        'background-opacity': 0.04,
        'border-color': 'rgba(255,255,255,0.08)',
        'border-width': 1,
        'border-opacity': 1,
        'label': 'data(label)',
        'text-valign': 'top',
        'text-halign': 'center',
        'font-size': '10px',
        'color': 'rgba(255,255,255,0.3)',
        'font-weight': '500',
        'padding': '18px',
        'shape': 'round-rectangle',
        'text-margin-y': -6
      }
    },
    {
      selector: '.compound-programs',
      style: {
        'background-color': '#68d391',
        'background-opacity': 0.03,
        'border-color': 'rgba(104,211,145,0.15)',
      }
    }
  ];

  for (const [cls, colors] of Object.entries(CLASS_COLORS)) {
    const style = {
      'background-color': colors.bg,
      'color': colors.text,
      'border-color': colors.border
    };
    if (cls === 'contractor' || cls === 'unknown') {
      style['border-style'] = 'dashed';
    }
    styles.push({ selector: '.' + cls, style });
  }

  styles.push({
    selector: 'edge',
    style: {
      'line-color': 'data(lineColor)',
      'width': 'data(lineWidth)',
      'target-arrow-color': 'data(lineColor)',
      'target-arrow-shape': 'triangle',
      'arrow-scale': 0.7,
      'curve-style': 'bezier',
      'opacity': 0.85
    }
  });

  styles.push({ selector: '.reporting', style: { 'line-style': 'solid' } });
  styles.push({ selector: '.internal-dotted', style: { 'line-style': 'dashed', 'line-dash-pattern': [6, 4] } });
  styles.push({ selector: '.subgraph-internal', style: { 'line-style': 'solid' } });

  styles.push({
    selector: '.affiliation',
    style: {
      'line-style': 'dashed',
      'line-dash-pattern': [6, 4],
      'label': 'data(label)',
      'font-size': '7px',
      'color': '#5ce0a0',
      'font-weight': 'bold',
      'text-rotation': 'autorotate',
      'text-margin-y': -7,
      'text-background-color': '#0c0e1a',
      'text-background-opacity': 0.85,
      'text-background-padding': '2px',
      'target-arrow-shape': 'none'
    }
  });

  styles.push({
    selector: '.program-link',
    style: {
      'line-style': 'dashed',
      'line-dash-pattern': [5, 3],
      'target-arrow-shape': 'none'
    }
  });

  styles.push({ selector: '.hidden', style: { 'display': 'none' } });

  return styles;
}

// ==================== LAYOUT ====================

function buildLayoutOptions(useFallback) {
  if (useFallback) {
    return {
      name: 'cose',
      animate: false,
      fit: true,
      padding: 40,
      nodeDimensionsIncludeLabels: true,
      idealEdgeLength: 100,
      nodeRepulsion: 8000,
      edgeElasticity: 0.45,
      nestingFactor: 0.1,
      gravity: 0.25,
      numIter: 1000
    };
  }

  const depths = computeDepths();

  // Only add constraints for edges where both nodes exist
  const allNodeIds = new Set(Object.keys(NODES));
  PROGRAM_BOXES.forEach(p => allNodeIds.add(p.id));

  const relativePlacementConstraint = [];
  for (const [f, t] of REPORTING) {
    if (allNodeIds.has(f) && allNodeIds.has(t)) {
      relativePlacementConstraint.push({ top: f, bottom: t, gap: 80 });
    }
  }
  for (const [f, t] of INTERNAL_DOTTED) {
    if (allNodeIds.has(f) && allNodeIds.has(t)) {
      relativePlacementConstraint.push({ top: f, bottom: t, gap: 80 });
    }
  }

  const depthGroups = {};
  for (const [id, depth] of Object.entries(depths)) {
    if (NODES[id] && NODES[id].org === internalOrgKey) {
      if (!depthGroups[depth]) depthGroups[depth] = [];
      depthGroups[depth].push(id);
    }
  }
  const horizontalAlign = [];
  for (const group of Object.values(depthGroups)) {
    if (group.length > 1) horizontalAlign.push(group);
  }

  return {
    name: 'fcose',
    animate: false,
    fit: true,
    padding: 40,
    nodeDimensionsIncludeLabels: true,
    idealEdgeLength: 100,
    nodeRepulsion: 8000,
    edgeElasticity: 0.45,
    nestingFactor: 0.1,
    gravity: 0.25,
    gravityRange: 3.8,
    numIter: 2500,
    relativePlacementConstraint,
    alignmentConstraint: { vertical: [], horizontal: horizontalAlign },
    quality: 'proof'
  };
}

// ==================== FILTERING ====================

function applyFilter() {
  const vis = getVisible();

  cy.nodes('[nodeType="person"]').forEach(n => {
    if (vis.has(n.id())) { n.removeClass('hidden'); } else { n.addClass('hidden'); }
  });

  cy.nodes('[nodeType="program"]').forEach(n => {
    if (activePrograms.has(n.data('progKey'))) { n.removeClass('hidden'); } else { n.addClass('hidden'); }
  });

  cy.edges().forEach(e => {
    const srcHidden = e.source().hasClass('hidden');
    const tgtHidden = e.target().hasClass('hidden');
    const prog = e.data('prog');
    const edgeType = e.data('edgeType');
    let hide = srcHidden || tgtHidden;
    if (!hide && (edgeType === 'affiliation' || edgeType === 'program_link') && prog) {
      hide = !activePrograms.has(prog);
    }
    if (hide) { e.addClass('hidden'); } else { e.removeClass('hidden'); }
  });

  cy.nodes('[nodeType="compound"]').forEach(n => {
    const children = n.children();
    if (children.length === 0 || children.every(c => c.hasClass('hidden'))) {
      n.addClass('hidden');
    } else {
      n.removeClass('hidden');
    }
  });

  const ver = window.__EMBEDDED_VERSION__ ? ' &middot; v' + window.__EMBEDDED_VERSION__ : '';
  document.getElementById('subtitle').innerHTML =
    vis.size + ' people &middot; org intelligence map' + ver;
  doAutoFit();
}

let rt;
function scheduleRender() { clearTimeout(rt); rt = setTimeout(applyFilter, 50); }

// ==================== NODE SIZE CONTROL ====================

window._onNodeSize = function(val) {
  nodeScale = val / 100;
  const d = getNodeDims();
  document.getElementById('size-val').textContent = val + '%';

  cy.batch(function() {
    cy.nodes('[nodeType="person"], [nodeType="program"]').forEach(n => {
      n.style({
        'width': d.w + 'px',
        'height': d.h + 'px',
        'font-size': d.font + 'px',
        'text-max-width': d.maxText + 'px'
      });
    });
  });
};

window._onTextSize = function(val) {
  textScale = val / 100;
  const d = getNodeDims();
  document.getElementById('text-size-val').textContent = val + '%';

  cy.batch(function() {
    cy.nodes('[nodeType="person"], [nodeType="program"]').forEach(n => {
      n.style({
        'font-size': d.font + 'px',
        'text-max-width': d.maxText + 'px'
      });
    });
  });
};

// ==================== SIDEBAR ====================

const SP_ICON = '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8.5l2.5-2.5M9.5 5L12 2.5M12 2.5h-3M12 2.5v3M10 8v4.5a1 1 0 01-1 1H3.5a1 1 0 01-1-1V6.5a1 1 0 011-1H8"/></svg>';

function spLink(url) {
  if (!url) return '';
  return ' <a class="sp-link" href="' + url + '" target="_blank" rel="noopener" title="Open in SharePoint">' + SP_ICON + '</a>';
}

function buildSidebar() {
  let h = '<div class="filter-section"><h3>Organizations</h3>';
  h += '<label class="filter-item disabled"><input type="checkbox" checked disabled>';
  h += '<span class="sw" style="background:#2b4a7a"></span> ' + (orgData.company || '{{COMPANY_NAME}}') + ' (always on)</label>';
  for (const o of ORG_LIST) {
    h += '<label class="filter-item"><input type="checkbox" id="org-' + o.key + '" checked onchange="window._onOrg()">';
    h += '<span class="sw" style="background:' + o.color + '"></span> ' + o.label + '</label>';
  }
  h += '</div>';

  if (useEngagements) {
    // Engagement / Workstream tree
    h += '<div class="filter-section"><h3>Engagements</h3>';
    for (const eng of ENGAGEMENT_DATA) {
      h += '<div class="filter-item" style="display:flex;align-items:center">';
      h += '<label style="display:flex;align-items:center;gap:8px;cursor:pointer;flex:1">';
      h += '<input type="checkbox" id="eng-' + eng.key + '" checked onchange="window._onEngagement(\'' + eng.key + '\')">';
      h += '<span class="sw" style="background:#4c8dff"></span> ' + eng.label + '</label>';
      h += spLink(eng.sharepoint_url);
      h += '</div>';
      for (const ws of eng.workstreams) {
        const wsFullKey = eng.key + '/' + ws.key;
        const docCount = DOC_COUNTS[wsFullKey] || 0;
        const wsClass = docCount > 0 ? 'filter-item child ws-clickable' : 'filter-item child';
        h += '<div class="' + wsClass + '" style="display:flex;align-items:center">';
        h += '<label style="display:flex;align-items:center;gap:8px;cursor:pointer;flex:1">';
        h += '<input type="checkbox" id="ws-' + wsFullKey + '" checked onchange="window._onWorkstream(\'' + eng.key + '\')">';
        h += ws.label;
        if (docCount > 0) h += '<span class="doc-badge" onclick="event.preventDefault();event.stopPropagation();window._showWsDocs(\'' + wsFullKey + '\')" title="' + docCount + ' documents">' + docCount + ' docs</span>';
        h += '</label>';
        h += spLink(ws.sharepoint_url);
        h += '</div>';
      }
    }
    h += '</div>';
  } else {
    // Fallback: program-based sidebar
    h += '<div class="filter-section"><h3>Programs</h3>';
    for (const parent of PROGRAM_TREE) {
      if (parent.children.length > 0) {
        h += '<label class="filter-item"><input type="checkbox" id="prog-' + parent.key + '" checked onchange="window._onParent(\'' + parent.key + '\')">';
        h += '<span class="sw" style="background:#68d391"></span> ' + parent.label + '</label>';
        for (const c of parent.children) {
          h += '<label class="filter-item child"><input type="checkbox" id="prog-' + c.key + '" checked onchange="window._onChild(\'' + parent.key + '\')">';
          h += c.label + '</label>';
        }
      } else {
        h += '<label class="filter-item"><input type="checkbox" id="prog-' + parent.key + '" checked onchange="window._onStandalone()">';
        h += '<span class="sw" style="background:#68d391"></span> ' + parent.label + '</label>';
      }
    }
    h += '</div>';
  }

  document.getElementById('filter-content').innerHTML = h;
}

// ==================== GLOBAL FUNCTIONS ====================

window.toggleSidebar = function() { document.getElementById('sidebar').classList.toggle('collapsed'); };

window.resetFilters = function() {
  for (const o of ORG_LIST) document.getElementById('org-' + o.key).checked = true;
  activeOrgs = new Set(ORG_LIST.map(o => o.key));

  if (useEngagements) {
    for (const eng of ENGAGEMENT_DATA) {
      const engEl = document.getElementById('eng-' + eng.key);
      if (engEl) { engEl.checked = true; engEl.indeterminate = false; }
      for (const ws of eng.workstreams) {
        const wsEl = document.getElementById('ws-' + eng.key + '/' + ws.key);
        if (wsEl) wsEl.checked = true;
      }
    }
    activeWorkstreams = new Set(ALL_WS_KEYS);
    syncEngagements();
  } else {
    for (const p of PROGRAM_TREE) {
      const el = document.getElementById('prog-' + p.key);
      el.checked = true; el.indeterminate = false;
      for (const c of p.children) document.getElementById('prog-' + c.key).checked = true;
    }
    activePrograms = new Set(ALL_PROG_KEYS);
  }
  applyFilter();
};

window.zoomIn = function() {
  cy.zoom({ level: cy.zoom() * 1.25, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
};
window.zoomOut = function() {
  cy.zoom({ level: cy.zoom() / 1.25, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
};
let autoFit = true;
window._toggleAutoFit = function(on) { autoFit = on; };

function doAutoFit() {
  if (autoFit) cy.fit(cy.elements(':visible'), 40);
}

window.resetView = function() {
  cy.fit(cy.elements(':visible'), 40);
};
window.reLayout = function() {
  try {
    cy.layout(buildLayoutOptions(false)).run();
  } catch(e) {
    console.warn('fcose layout failed, using fallback:', e.message);
    cy.layout(buildLayoutOptions(true)).run();
  }
  setTimeout(() => cy.fit(cy.elements(':visible'), 40), 100);
};

window.addEventListener('keydown', function(e) {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === '=' || e.key === '+') zoomIn();
  else if (e.key === '-') zoomOut();
  else if (e.key === '0') resetView();
});

// ==================== DETAIL PANEL ====================

const detailPanel = document.getElementById('detail-panel');
const detailBody = document.getElementById('detail-body');
const detailHeaderLabel = document.getElementById('detail-header-label');

window.closeDetail = function() {
  detailPanel.classList.remove('open');
};

function escHtml(str) {
  if (!str) return '';
  return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function showDetail(nodeData) {
  const p = nodeData._person || {};
  const name = p.name || nodeData.label?.split('\n')[0] || nodeData.id;
  const title = p.title || '';

  detailHeaderLabel.textContent = 'Person';
  let h = '';

  // Name + title header
  h += '<div class="detail-name">' + escHtml(name) + '</div>';
  if (title) h += '<div class="detail-title">' + escHtml(title) + '</div>';

  // Badges row: level, confidence
  const badges = [];
  if (p.level) badges.push(escHtml(p.level));
  if (p.confidence) badges.push('<span class="detail-badge confidence-' + escHtml(p.confidence) + '">' + escHtml(p.confidence) + '</span>');
  if (badges.length) h += '<div style="margin-bottom:12px">' + badges.map(b => '<span class="detail-badge">' + b + '</span>').join('') + '</div>';

  // Contact info
  const contactLines = [];
  if (p.email) contactLines.push('<a href="mailto:' + escHtml(p.email) + '">' + escHtml(p.email) + '</a>');
  if (p.phone) contactLines.push(escHtml(p.phone));
  if (p.linkedin && p.linkedin !== 'N/A') contactLines.push('<a href="' + escHtml(p.linkedin) + '" target="_blank" rel="noopener">LinkedIn</a>');
  if (p.location) contactLines.push(escHtml(p.location));
  if (contactLines.length) {
    h += '<div class="detail-section"><h4>Contact</h4><div class="detail-val">' + contactLines.join('<br>') + '</div></div>';
  }

  // Reporting
  const reportLines = [];
  if (p.reports_to) reportLines.push('Reports to: ' + escHtml(p.reports_to));
  if (p.dotted_to) reportLines.push('Dotted to: ' + escHtml(p.dotted_to));
  if (p.start_date) reportLines.push('Start date: ' + escHtml(p.start_date));
  if (reportLines.length) {
    h += '<div class="detail-section"><h4>Organization</h4><div class="detail-val">' + reportLines.join('<br>') + '</div></div>';
  }

  // Background
  if (p.background) {
    h += '<div class="detail-section"><h4>Background</h4><div class="detail-val">' + escHtml(p.background) + '</div></div>';
  }

  // Email signals
  if (p.email_signals) {
    h += '<div class="detail-section"><h4>Email Signals</h4><div class="detail-signals">' + escHtml(p.email_signals) + '</div></div>';
  }

  // Notes (externals)
  if (p.notes) {
    h += '<div class="detail-section"><h4>Notes</h4><div class="detail-val">' + escHtml(p.notes) + '</div></div>';
  }

  // Programs
  if (nodeData.progs && nodeData.progs.length) {
    h += '<div class="detail-section"><h4>Programs</h4><div>' + nodeData.progs.map(p => '<span class="detail-badge">' + escHtml(p) + '</span>').join('') + '</div></div>';
  }

  // Any remaining fields we haven't shown
  const shownKeys = new Set(['name','title','email','phone','linkedin','location','level','confidence',
    'reports_to','dotted_to','start_date','background','email_signals','notes','programs','progs',
    'direct_reports','affiliations','cls','org','_person','label','id','nodeType','parent','progKey']);
  const extra = Object.entries(p).filter(([k,v]) => !shownKeys.has(k) && v != null && v !== '' && v !== 'N/A');
  for (const [k, v] of extra) {
    const label = k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const val = typeof v === 'object' ? JSON.stringify(v) : String(v);
    if (val.length > 0 && val !== '[]' && val !== 'null') {
      h += '<div class="detail-section"><h4>' + escHtml(label) + '</h4><div class="detail-val">' + escHtml(val) + '</div></div>';
    }
  }

  detailBody.innerHTML = h;
  detailBody.classList.add('no-knowledge');
  detailPanel.classList.add('open');
}

function showProgramDetail(nodeData) {
  const p = nodeData._prog || {};
  const name = p.name || p.description || nodeData.progKey || nodeData.label;
  const progKey = nodeData.progKey || p.key || '';

  detailHeaderLabel.textContent = 'Program';
  let h = '';

  // Program name with green accent
  h += '<div class="detail-prog-header">' + escHtml(progKey.replace(/_/g, ' ')) + '</div>';
  if (p.description) h += '<div class="detail-title">' + escHtml(p.description) + '</div>';

  // Status badge
  if (p.status) {
    h += '<div style="margin:8px 0 12px"><span class="detail-status">' + escHtml(p.status) + '</span></div>';
  }

  // Key fields
  const fields = [
    ['governance', 'Governance'],
    ['cloud_provider', 'Cloud Provider'],
    ['budget', 'Budget'],
  ];
  for (const [key, label] of fields) {
    if (p[key]) {
      h += '<div class="detail-section"><h4>' + label + '</h4><div class="detail-val">' + escHtml(p[key]) + '</div></div>';
    }
  }

  // Parent program
  if (p.parent) {
    h += '<div class="detail-section"><h4>Parent Program</h4><div class="detail-val">' + escHtml(p.parent.replace(/_/g, ' ')) + '</div></div>';
  }

  // Sub-programs
  if (p.sub_programs && p.sub_programs.length) {
    const subs = p.sub_programs.map(s => typeof s === 'string' ? s : s.key || s.name);
    h += '<div class="detail-section"><h4>Sub-Programs</h4><div>';
    h += subs.map(s => '<span class="detail-badge">' + escHtml(s.replace(/_/g, ' ')) + '</span>').join('');
    h += '</div></div>';
  }

  // Key contacts (clickable — navigate to person node)
  if (p.key_altera_contacts && p.key_altera_contacts.length) {
    h += '<div class="detail-section"><h4>Key Contacts</h4><div>';
    for (const contact of p.key_altera_contacts) {
      const cid = contact.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/(^_|_$)/g, '');
      h += '<span class="detail-contact-chip" onclick="window._focusNode(\'' + cid + '\')">' + escHtml(contact) + '</span>';
    }
    h += '</div></div>';
  }

  // Any extra fields
  const shownKeys = new Set(['key','name','description','status','governance','cloud_provider',
    'budget','parent','sub_programs','key_altera_contacts']);
  const extra = Object.entries(p).filter(([k,v]) => !shownKeys.has(k) && v != null && v !== '' && v !== 'N/A');
  for (const [k, v] of extra) {
    const label = k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const val = typeof v === 'object' ? JSON.stringify(v) : String(v);
    if (val.length > 0 && val !== '[]' && val !== 'null') {
      h += '<div class="detail-section"><h4>' + escHtml(label) + '</h4><div class="detail-val">' + escHtml(val) + '</div></div>';
    }
  }

  // Knowledge log entries for this program
  const progKnowledge = KNOWLEDGE_BY_PROG[progKey] || [];
  h += renderKnowledgeSection(progKnowledge, 'Knowledge Log');

  detailBody.innerHTML = h;
  detailBody.classList.toggle('no-knowledge', !progKnowledge.length);
  detailPanel.classList.add('open');
}

// Render knowledge entries as scrollable HTML
function renderKnowledgeSection(entries, label) {
  if (!entries || !entries.length) return '';
  let h = '<div class="knowledge-section">';
  h += '<div class="detail-section"><h4>' + escHtml(label) + ' <span class="k-count-badge">' + entries.length + '</span></h4></div>';
  h += '<div class="knowledge-scroll">';
  // Sort by date desc
  const sorted = entries.slice().sort((a, b) => (b.date || '').localeCompare(a.date || ''));
  for (const k of sorted) {
    const typeLower = (k.type || 'status').toLowerCase();
    h += '<div class="k-entry">';
    h += '<span class="k-type k-type-' + typeLower + '">' + escHtml(k.type || 'STATUS') + '</span>';
    h += '<span class="k-summary">' + escHtml(k.summary || '') + '</span>';
    if (k.detail) h += '<div class="k-detail">' + escHtml(k.detail) + '</div>';
    const meta = [];
    if (k.date) meta.push(k.date);
    if (k.source) meta.push(k.source.replace(/"/g, ''));
    if (meta.length) h += '<div class="k-meta">' + escHtml(meta.join(' · ')) + '</div>';
    h += '</div>';
  }
  h += '</div></div>';
  return h;
}

// Show workstream documents in the detail panel
window._showWsDocs = function(wsKey) {
  const docs = DOC_BY_WS[wsKey] || [];
  if (!docs.length) return;

  const parts = wsKey.split('/');
  const engKey = parts[0];
  const wsName = parts.slice(1).join('/');

  // Find the workstream label from engagement data
  let wsLabel = wsName;
  for (const eng of ENGAGEMENT_DATA) {
    if (eng.key === engKey) {
      for (const ws of eng.workstreams) {
        if (ws.key === wsName) { wsLabel = ws.label; break; }
      }
      break;
    }
  }

  detailHeaderLabel.textContent = 'Documents';
  let h = '';
  h += '<div class="detail-prog-header" style="color:var(--accent)">' + escHtml(wsLabel) + '</div>';
  h += '<div class="detail-title" style="margin-bottom:14px">' + docs.length + ' document' + (docs.length !== 1 ? 's' : '') + '</div>';

  const typeIcons = { pptx: 'PPTX', xlsx: 'XLSX', docx: 'DOCX', pdf: 'PDF' };

  for (const doc of docs) {
    h += '<div class="doc-item">';
    h += '<span class="doc-icon">' + (typeIcons[doc.file_type] || doc.file_type) + '</span>';
    h += '<div style="flex:1;min-width:0">';
    h += '<div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis" title="' + escHtml(doc.relative_path) + '">' + escHtml(doc.filename) + '</div>';
    h += '</div>';
    const size = doc.size > 1048576 ? (doc.size / 1048576).toFixed(1) + ' MB' : Math.round(doc.size / 1024) + ' KB';
    const date = doc.modified ? doc.modified.slice(0, 10) : '';
    h += '<span class="doc-meta">' + size + (date ? ' &middot; ' + date : '') + '</span>';
    h += '</div>';
  }

  // Knowledge log entries for this workstream
  const wsKnowledge = KNOWLEDGE_BY_WS[wsKey] || [];
  h += renderKnowledgeSection(wsKnowledge, 'Knowledge Log');

  detailBody.innerHTML = h;
  detailBody.classList.toggle('no-knowledge', !wsKnowledge.length);
  detailPanel.classList.add('open');
};

// Focus a node by ID (used by contact chips in program detail)
window._focusNode = function(nodeId) {
  const node = cy.$('#' + nodeId);
  if (node.length) {
    cy.animate({ center: { eles: node }, zoom: Math.max(cy.zoom(), 1.5) }, { duration: 300 });
    setTimeout(() => showDetail(node.data()), 350);
  }
};

// Resize handle
(function() {
  const handle = document.getElementById('detail-resize');
  let dragging = false, startX, startW;
  handle.addEventListener('mousedown', function(e) {
    dragging = true; startX = e.clientX;
    startW = detailPanel.offsetWidth;
    handle.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });
  document.addEventListener('mousemove', function(e) {
    if (!dragging) return;
    const newW = Math.max(200, Math.min(window.innerWidth * 0.5, startW + (startX - e.clientX)));
    detailPanel.style.width = newW + 'px';
  });
  document.addEventListener('mouseup', function() {
    if (!dragging) return;
    dragging = false;
    handle.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
})();

// ==================== INIT ====================

buildSidebar();

const elements = buildElements();
let layoutOpts;
try {
  // Test that fcose layout options build without error
  layoutOpts = buildLayoutOptions(false);
} catch(e) {
  console.warn('fcose layout options failed, using fallback:', e.message);
  layoutOpts = buildLayoutOptions(true);
}

let cy;
try {
  cy = cytoscape({
    container: document.getElementById('cy'),
    elements: [...elements.nodes, ...elements.edges],
    style: buildStylesheet(),
    layout: layoutOpts,
    minZoom: 0.1,
    maxZoom: 5,
    wheelSensitivity: 0.3,
    boxSelectionEnabled: false
  });
} catch(e) {
  console.warn('Cytoscape init with fcose failed, retrying with cose fallback:', e.message);
  cy = cytoscape({
    container: document.getElementById('cy'),
    elements: [...elements.nodes, ...elements.edges],
    style: buildStylesheet(),
    layout: buildLayoutOptions(true),
    minZoom: 0.1,
    maxZoom: 5,
    wheelSensitivity: 0.3,
    boxSelectionEnabled: false
  });
}

cy.on('zoom', function() {
  document.getElementById('zoom-label').textContent = Math.round(cy.zoom() * 100) + '%';
});

cy.on('dbltap', function(e) {
  if (e.target === cy) {
    cy.zoom({ level: cy.zoom() * 1.5, renderedPosition: e.renderedPosition });
  }
});

cy.on('tap', 'node[nodeType="person"]', function(e) {
  showDetail(e.target.data());
});

cy.on('tap', 'node[nodeType="program"]', function(e) {
  showProgramDetail(e.target.data());
});

// Click on background closes detail panel
cy.on('tap', function(e) {
  if (e.target === cy) closeDetail();
});

cy.on('dragfree', 'node', function() {
  doAutoFit();
});

applyFilter();

}); // end DOMContentLoaded
</script>
</body>
</html>
